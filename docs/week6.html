<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />




<title>Session 6 – Grouping and combining data</title>

<script src="site_libs/header-attrs-2.29/header-attrs.js"></script>
<script src="site_libs/jquery-3.6.0/jquery-3.6.0.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="site_libs/bootstrap-3.3.5/css/bootstrap.min.css" rel="stylesheet" />
<script src="site_libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/respond.min.js"></script>
<style>h1 {font-size: 34px;}
       h1.title {font-size: 38px;}
       h2 {font-size: 30px;}
       h3 {font-size: 24px;}
       h4 {font-size: 18px;}
       h5 {font-size: 16px;}
       h6 {font-size: 12px;}
       code {color: inherit; background-color: rgba(0, 0, 0, 0.04);}
       pre:not([class]) { background-color: white }</style>
<script src="site_libs/jqueryui-1.13.2/jquery-ui.min.js"></script>
<link href="site_libs/tocify-1.9.1/jquery.tocify.css" rel="stylesheet" />
<script src="site_libs/tocify-1.9.1/jquery.tocify.js"></script>
<script src="site_libs/navigation-1.1/tabsets.js"></script>
<link href="site_libs/highlightjs-9.12.0/default.css" rel="stylesheet" />
<script src="site_libs/highlightjs-9.12.0/highlight.js"></script>
<link href="site_libs/font-awesome-6.5.2/css/all.min.css" rel="stylesheet" />
<link href="site_libs/font-awesome-6.5.2/css/v4-shims.min.css" rel="stylesheet" />

<style type="text/css">
  code{white-space: pre-wrap;}
  span.smallcaps{font-variant: small-caps;}
  span.underline{text-decoration: underline;}
  div.column{display: inline-block; vertical-align: top; width: 50%;}
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  ul.task-list{list-style: none;}
    </style>

<style type="text/css">code{white-space: pre;}</style>
<script type="text/javascript">
if (window.hljs) {
  hljs.configure({languages: []});
  hljs.initHighlightingOnLoad();
  if (document.readyState && document.readyState === "complete") {
    window.setTimeout(function() { hljs.initHighlighting(); }, 0);
  }
}
</script>






<link rel="stylesheet" href="styles.css" type="text/css" />



<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
img {
  max-width:100%;
}
.tabbed-pane {
  padding-top: 12px;
}
.html-widget {
  margin-bottom: 20px;
}
button.code-folding-btn:focus {
  outline: none;
}
summary {
  display: list-item;
}
details > summary > p:only-child {
  display: inline;
}
pre code {
  padding: 0;
}
</style>


<style type="text/css">
.dropdown-submenu {
  position: relative;
}
.dropdown-submenu>.dropdown-menu {
  top: 0;
  left: 100%;
  margin-top: -6px;
  margin-left: -1px;
  border-radius: 0 6px 6px 6px;
}
.dropdown-submenu:hover>.dropdown-menu {
  display: block;
}
.dropdown-submenu>a:after {
  display: block;
  content: " ";
  float: right;
  width: 0;
  height: 0;
  border-color: transparent;
  border-style: solid;
  border-width: 5px 0 5px 5px;
  border-left-color: #cccccc;
  margin-top: 5px;
  margin-right: -10px;
}
.dropdown-submenu:hover>a:after {
  border-left-color: #adb5bd;
}
.dropdown-submenu.pull-left {
  float: none;
}
.dropdown-submenu.pull-left>.dropdown-menu {
  left: -100%;
  margin-left: 10px;
  border-radius: 6px 0 6px 6px;
}
</style>

<script type="text/javascript">
// manage active state of menu based on current page
$(document).ready(function () {
  // active menu anchor
  href = window.location.pathname
  href = href.substr(href.lastIndexOf('/') + 1)
  if (href === "")
    href = "index.html";
  var menuAnchor = $('a[href="' + href + '"]');

  // mark the anchor link active (and if it's in a dropdown, also mark that active)
  var dropdown = menuAnchor.closest('li.dropdown');
  if (window.bootstrap) { // Bootstrap 4+
    menuAnchor.addClass('active');
    dropdown.find('> .dropdown-toggle').addClass('active');
  } else { // Bootstrap 3
    menuAnchor.parent().addClass('active');
    dropdown.addClass('active');
  }

  // Navbar adjustments
  var navHeight = $(".navbar").first().height() + 15;
  var style = document.createElement('style');
  var pt = "padding-top: " + navHeight + "px; ";
  var mt = "margin-top: -" + navHeight + "px; ";
  var css = "";
  // offset scroll position for anchor links (for fixed navbar)
  for (var i = 1; i <= 6; i++) {
    css += ".section h" + i + "{ " + pt + mt + "}\n";
  }
  style.innerHTML = "body {" + pt + "padding-bottom: 40px; }\n" + css;
  document.head.appendChild(style);
});
</script>

<!-- tabsets -->

<style type="text/css">
.tabset-dropdown > .nav-tabs {
  display: inline-table;
  max-height: 500px;
  min-height: 44px;
  overflow-y: auto;
  border: 1px solid #ddd;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs > li.active:before, .tabset-dropdown > .nav-tabs.nav-tabs-open:before {
  content: "\e259";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li.active:before {
  content: "\e258";
  font-family: 'Glyphicons Halflings';
  border: none;
}

.tabset-dropdown > .nav-tabs > li.active {
  display: block;
}

.tabset-dropdown > .nav-tabs > li > a,
.tabset-dropdown > .nav-tabs > li > a:focus,
.tabset-dropdown > .nav-tabs > li > a:hover {
  border: none;
  display: inline-block;
  border-radius: 4px;
  background-color: transparent;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li {
  display: block;
  float: none;
}

.tabset-dropdown > .nav-tabs > li {
  display: none;
}
</style>

<!-- code folding -->



<style type="text/css">

#TOC {
  margin: 25px 0px 20px 0px;
}
@media (max-width: 768px) {
#TOC {
  position: relative;
  width: 100%;
}
}

@media print {
.toc-content {
  /* see https://github.com/w3c/csswg-drafts/issues/4434 */
  float: right;
}
}

.toc-content {
  padding-left: 30px;
  padding-right: 40px;
}

div.main-container {
  max-width: 1200px;
}

div.tocify {
  width: 20%;
  max-width: 260px;
  max-height: 85%;
}

@media (min-width: 768px) and (max-width: 991px) {
  div.tocify {
    width: 25%;
  }
}

@media (max-width: 767px) {
  div.tocify {
    width: 100%;
    max-width: none;
  }
}

.tocify ul, .tocify li {
  line-height: 20px;
}

.tocify-subheader .tocify-item {
  font-size: 0.90em;
}

.tocify .list-group-item {
  border-radius: 0px;
}


</style>



</head>

<body>


<div class="container-fluid main-container">


<!-- setup 3col/9col grid for toc_float and main content  -->
<div class="row">
<div class="col-xs-12 col-sm-4 col-md-3">
<div id="TOC" class="tocify">
</div>
</div>

<div class="toc-content col-xs-12 col-sm-8 col-md-9">




<div class="navbar navbar-default  navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-bs-toggle="collapse" data-target="#navbar" data-bs-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="index.html"><img style="width: 120px; float: left; margin-top: 0px; margin-right: 20px;" src="images/CRUK_CI_logo.png"/>R for Biologists&nbsp;&nbsp;&nbsp;</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">
    Contents
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="week1.html">Week 1 - An introduction to RStudio, R objects, data types, functions and vectors</a>
    </li>
    <li>
      <a href="week2.html">Week 2 - An introduction to other data structures</a>
    </li>
    <li>
      <a href="week3.html">Week 3 - Working with data in R</a>
    </li>
    <li>
      <a href="week4.html">Week 4 - Data visualization with ggplot2</a>
    </li>
    <li>
      <a href="week5.html">Week 5 - Data manipulation using dplyr</a>
    </li>
    <li>
      <a href="week6.html">Week 6 - Grouping and combining data</a>
    </li>
    <li>
      <a href="week7.html">Week 7 - Restructuring data for analysis</a>
    </li>
  </ul>
</li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        <li>
  <a href="https://github.com/bioinformatics-core-shared-training/Bitesize-R">
    <span class="fa fa-github fa-lg"></span>
     
  </a>
</li>
      </ul>
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

<div id="header">



<h1 class="title toc-ignore">Session 6 – Grouping and combining
data</h1>

</div>


<blockquote>
<h4 id="learning-objectives">Learning objectives</h4>
<ul>
<li>Use <code>group_by()</code> with <code>summarise()</code> to compute
summary values for groups of observations</li>
<li>Use <code>count()</code> to count the numbers of observations within
categories</li>
<li>Combine data from two tables based on a common identifier
(<code>join</code> operations)</li>
<li>Customize plots created using ggplot2 by changing labels, scales and
colours</li>
</ul>
</blockquote>
<div id="grouping-and-combining-data" class="section level1">
<h1>Grouping and combining data</h1>
<p>In this session, we’ll look at some more useful functions provided by
the <strong>dplyr</strong> package, the ‘workhorse’ in the tidyverse
family for manipulating tabular data. Continuing from the last session,
we’ll see how we can summarise data for groups of observations within
different categories. We’ll also show how dplyr allows us to combine
data for the same observational unit, e.g. person or date, that comes
from different sources and is read into R in different tables.</p>
<p>We’ll also look at how to customize the plots we create using
<strong>ggplot2</strong>, in particular how we can add or change titles
and labels, how we can adjust the way the axes are displayed and how we
can use a colour scheme of our choosing.</p>
<p><strong>dplyr</strong> and <strong>ggplot2</strong> are core
component packages within the tidyverse and both get loaded as part of
the tidyverse.</p>
<pre class="r"><code>library(tidyverse)</code></pre>
<pre><code>## ── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──
## ✔ dplyr     1.1.4     ✔ readr     2.1.5
## ✔ forcats   1.0.0     ✔ stringr   1.5.1
## ✔ ggplot2   3.5.1     ✔ tibble    3.2.1
## ✔ lubridate 1.9.4     ✔ tidyr     1.3.1
## ✔ purrr     1.0.4     
## ── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──
## ✖ dplyr::filter() masks stats::filter()
## ✖ dplyr::lag()    masks stats::lag()
## ℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors</code></pre>
<p>To demonstrate how these grouping and combining functions work and to
illustrate customization of plots, we’ll again use the METABRIC data
set.</p>
<pre class="r"><code>metabric &lt;- read_csv(&quot;data/metabric_clinical_and_expression_data.csv&quot;)
metabric</code></pre>
<pre><code>## # A tibble: 1,904 × 32
##    Patient_ID Cohort Age_at_diagnosis Survival_time Survival_status Vital_status
##    &lt;chr&gt;       &lt;dbl&gt;            &lt;dbl&gt;         &lt;dbl&gt; &lt;chr&gt;           &lt;chr&gt;       
##  1 MB-0000         1             75.6         140.  LIVING          Living      
##  2 MB-0002         1             43.2          84.6 LIVING          Living      
##  3 MB-0005         1             48.9         164.  DECEASED        Died of Dis…
##  4 MB-0006         1             47.7         165.  LIVING          Living      
##  5 MB-0008         1             77.0          41.4 DECEASED        Died of Dis…
##  6 MB-0010         1             78.8           7.8 DECEASED        Died of Dis…
##  7 MB-0014         1             56.4         164.  LIVING          Living      
##  8 MB-0022         1             89.1          99.5 DECEASED        Died of Oth…
##  9 MB-0028         1             86.4          36.6 DECEASED        Died of Oth…
## 10 MB-0035         1             84.2          36.3 DECEASED        Died of Dis…
## # ℹ 1,894 more rows
## # ℹ 26 more variables: Chemotherapy &lt;chr&gt;, Radiotherapy &lt;chr&gt;,
## #   Tumour_size &lt;dbl&gt;, Tumour_stage &lt;dbl&gt;, Neoplasm_histologic_grade &lt;dbl&gt;,
## #   Lymph_nodes_examined_positive &lt;dbl&gt;, Lymph_node_status &lt;dbl&gt;,
## #   Cancer_type &lt;chr&gt;, ER_status &lt;chr&gt;, PR_status &lt;chr&gt;, HER2_status &lt;chr&gt;,
## #   HER2_status_measured_by_SNP6 &lt;chr&gt;, PAM50 &lt;chr&gt;, `3-gene_classifier` &lt;chr&gt;,
## #   Nottingham_prognostic_index &lt;dbl&gt;, Cellularity &lt;chr&gt;, …</code></pre>
</div>
<div id="grouping-observations" class="section level1">
<h1>Grouping observations</h1>
<div id="summaries-for-groups" class="section level2">
<h2>Summaries for groups</h2>
<p>In the previous session we introduced the <code>summarise()</code>
function for computing a summary value for one or more variables from
all rows in a table (data frame or tibble). For example, we computed the
mean expression of ESR1, the estrogen receptor alpha gene, as
follows.</p>
<pre class="r"><code>summarise(metabric, mean(ESR1))</code></pre>
<pre><code>## # A tibble: 1 × 1
##   `mean(ESR1)`
##          &lt;dbl&gt;
## 1         9.61</code></pre>
<p>While the <code>summarise()</code> function is useful on its own, it
becomes really powerful when applied to groups of observations within a
dataset. For example, we might be more interested in the mean ESR1
expression calculated separately for ER positive and ER negative
tumours. We could take each group in turn, filter the data frame to
contain only the rows for a given ER status, then apply the
<code>summarise()</code> function to compute the mean expression, but
that would be somewhat cumbersome. Even more so if we chose to do this
for a categorical variable with more than two states, e.g. for each of
the integrative clusters. Fortunately, the
<strong><code>group_by()</code></strong> function and
<strong>.by</strong> argument to summarise allow this to be done in one
simple step.</p>
<pre class="r"><code>metabric %&gt;%
    group_by(ER_status) %&gt;%
    summarise(mean(ESR1))</code></pre>
<pre><code>## # A tibble: 2 × 2
##   ER_status `mean(ESR1)`
##   &lt;chr&gt;            &lt;dbl&gt;
## 1 Negative          6.21
## 2 Positive         10.6</code></pre>
<p>or</p>
<pre class="r"><code>metabric %&gt;%
    summarise(mean(ESR1), .by = ER_status)</code></pre>
<pre><code>## # A tibble: 2 × 2
##   ER_status `mean(ESR1)`
##   &lt;chr&gt;            &lt;dbl&gt;
## 1 Positive         10.6 
## 2 Negative          6.21</code></pre>
<p>The following schematic contains another example using a simplified
subset of the METABRIC tumour samples to show what’s going on.</p>
<p><img src="images/group_and_summarise.png" /></p>
<p>We get an additional column in our output for the categorical
variable, <code>ER_status</code>, and a row for each category.</p>
<p>When we group by only one column there is no difference between the
two methods.</p>
<p>Incidentally, we should expect this result of ER-positive tumours
having a higher expression of ESR1 on average than ER-negative tumours.
Simple summaries like this are a good way of checking that what we think
we know actually holds true in the data we’re looking at. Note that the
expression values are on a log<sub>2</sub>scale so ER-positive breast
cancers express ESR1 at a level that is approximately 20 times greater,
on average, than that of ER-negative tumours.</p>
<pre class="r"><code>2 ^ (10.6 - 6.21)  # equivalent to (2 ^ 10.6) / (2 ^ 6.21)</code></pre>
<pre><code>## [1] 20.96629</code></pre>
<p>We can group by more than one column. When we do this there are some
differences by between using <strong>group_by</strong> or
<strong>.by</strong>.</p>
<p>Let’s say we want to look at ERBB2 expression in ER positive and
negative, but further divided by the cancer type.</p>
<pre class="r"><code>metabric %&gt;%
    group_by(ER_status, Cancer_type) %&gt;%
    summarise(mean(ERBB2))</code></pre>
<pre><code>## `summarise()` has grouped output by &#39;ER_status&#39;. You can override using the
## `.groups` argument.</code></pre>
<pre><code>## # A tibble: 13 × 3
## # Groups:   ER_status [2]
##    ER_status Cancer_type                               `mean(ERBB2)`
##    &lt;chr&gt;     &lt;chr&gt;                                             &lt;dbl&gt;
##  1 Negative  Breast                                            10.2 
##  2 Negative  Breast Invasive Ductal Carcinoma                  11.1 
##  3 Negative  Breast Invasive Lobular Carcinoma                 11.0 
##  4 Negative  Breast Invasive Mixed Mucinous Carcinoma           8.70
##  5 Negative  Breast Mixed Ductal and Lobular Carcinoma         10.1 
##  6 Negative  Metaplastic Breast Cancer                          8.44
##  7 Negative  &lt;NA&gt;                                              13.6 
##  8 Positive  Breast                                            10.4 
##  9 Positive  Breast Invasive Ductal Carcinoma                  10.7 
## 10 Positive  Breast Invasive Lobular Carcinoma                 10.6 
## 11 Positive  Breast Invasive Mixed Mucinous Carcinoma          10.4 
## 12 Positive  Breast Mixed Ductal and Lobular Carcinoma         10.5 
## 13 Positive  &lt;NA&gt;                                              10.8</code></pre>
<p>You can see that the tibble is still grouped by “ER_status”, this
means any subsequent operations will be carried out within the groupings
based on “ER_status”. Perhaps, after summarising, we want to find which
group has the maximum mean ERBB2 expression. We can use the dplyr
function <strong>top_n</strong> to get the top result.</p>
<pre class="r"><code>metabric %&gt;%
    group_by(ER_status, Cancer_type) %&gt;%
    summarise(ERBB2_mean = mean(ERBB2)) %&gt;%
    top_n(n = 1)</code></pre>
<pre><code>## `summarise()` has grouped output by &#39;ER_status&#39;. You can override using the
## `.groups` argument.
## Selecting by ERBB2_mean</code></pre>
<pre><code>## # A tibble: 2 × 3
## # Groups:   ER_status [2]
##   ER_status Cancer_type ERBB2_mean
##   &lt;chr&gt;     &lt;chr&gt;            &lt;dbl&gt;
## 1 Negative  &lt;NA&gt;              13.6
## 2 Positive  &lt;NA&gt;              10.8</code></pre>
<p>This gives us the top value for ER positive and ER negative groups
respectively.</p>
<p>If we don’t want the grouping to continue to be applied we need to
use <strong>ungroup()</strong>.</p>
<pre class="r"><code>metabric %&gt;%
    group_by(ER_status, Cancer_type) %&gt;%
    summarise(ERBB2_mean = mean(ERBB2)) %&gt;%
    ungroup() %&gt;%
    top_n(n = 1)</code></pre>
<pre><code>## `summarise()` has grouped output by &#39;ER_status&#39;. You can override using the
## `.groups` argument.
## Selecting by ERBB2_mean</code></pre>
<pre><code>## # A tibble: 1 × 3
##   ER_status Cancer_type ERBB2_mean
##   &lt;chr&gt;     &lt;chr&gt;            &lt;dbl&gt;
## 1 Negative  &lt;NA&gt;              13.6</code></pre>
<p>If instead we use <strong>.by</strong> to do the grouping, you will
see that the grouping is dropped after the summarise operation.</p>
<pre class="r"><code>metabric %&gt;%
    summarise(ERBB2_mean = mean(ERBB2), .by = c(ER_status, Cancer_type))</code></pre>
<pre><code>## # A tibble: 13 × 3
##    ER_status Cancer_type                               ERBB2_mean
##    &lt;chr&gt;     &lt;chr&gt;                                          &lt;dbl&gt;
##  1 Positive  Breast Invasive Ductal Carcinoma               10.7 
##  2 Positive  Breast Mixed Ductal and Lobular Carcinoma      10.5 
##  3 Positive  Breast Invasive Lobular Carcinoma              10.6 
##  4 Negative  Breast Invasive Ductal Carcinoma               11.1 
##  5 Positive  Breast Invasive Mixed Mucinous Carcinoma       10.4 
##  6 Negative  Breast Invasive Lobular Carcinoma              11.0 
##  7 Positive  Breast                                         10.4 
##  8 Negative  Breast                                         10.2 
##  9 Positive  &lt;NA&gt;                                           10.8 
## 10 Negative  &lt;NA&gt;                                           13.6 
## 11 Negative  Breast Mixed Ductal and Lobular Carcinoma      10.1 
## 12 Negative  Breast Invasive Mixed Mucinous Carcinoma        8.70
## 13 Negative  Metaplastic Breast Cancer                       8.44</code></pre>
<p>You should also notice, that the tibble returned by
<strong>group_by</strong> was sorted by our grouping columns, the tibble
returned when using <strong>.by</strong> is not sorted. In general,
using <strong>.by</strong> is simpler as you don’t have to worry about
doing the <strong>ungroup()</strong> afterwards.</p>
<p>Note: The <strong>.by</strong> and an equivalent <strong>by</strong>
(no dot) are available in other dplyr verbs, such as
<code>mutate()</code> and <code>filter()</code>, but not all, such as
<code>top_n()</code>.</p>
<p>As we saw in the previous session, we can summarize multiple
observations, e.g. the mean expression for other genes of interest, with
<code>summarise(across())</code>, this time using the PAM50
classification to define the groups.</p>
<pre class="r"><code>metabric %&gt;%
    summarise(across(c(ESR1, PGR, ERBB2), mean), .by = PAM50)</code></pre>
<pre><code>## # A tibble: 7 × 4
##   PAM50        ESR1   PGR ERBB2
##   &lt;chr&gt;       &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;
## 1 claudin-low  7.47  5.60  9.85
## 2 LumA        10.8   6.75 10.7 
## 3 LumB        11.0   6.39 10.6 
## 4 Her2         7.81  5.62 12.6 
## 5 Normal       9.50  6.21 10.8 
## 6 Basal        6.42  5.46 10.2 
## 7 NC          10.9   6.47 10.3</code></pre>
<p>We can also refine our groups by using more than one categorical
variable. Let’s subdivide the PAM50 groups by HER2 status to illustrate
this.</p>
<pre class="r"><code>metabric %&gt;%
    summarise(across(c(ESR1, PGR, ERBB2), mean), .by = c(PAM50, HER2_status))</code></pre>
<pre><code>## # A tibble: 13 × 5
##    PAM50       HER2_status  ESR1   PGR ERBB2
##    &lt;chr&gt;       &lt;chr&gt;       &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;
##  1 claudin-low Negative     7.52  5.61  9.58
##  2 LumA        Negative    10.8   6.77 10.6 
##  3 LumB        Negative    11.1   6.43 10.3 
##  4 Her2        Negative     8.82  5.83 10.9 
##  5 LumA        Positive    10.1   6.13 13.5 
##  6 claudin-low Positive     6.80  5.45 13.2 
##  7 Normal      Negative     9.68  6.28 10.5 
##  8 Basal       Negative     6.39  5.46  9.83
##  9 Her2        Positive     7.04  5.46 13.8 
## 10 LumB        Positive    10.2   5.98 13.4 
## 11 Basal       Positive     6.71  5.45 14.0 
## 12 Normal      Positive     7.77  5.54 13.5 
## 13 NC          Negative    10.9   6.47 10.3</code></pre>
<p>It can be quite useful to know how many observations are within each
group. We can use a special function, <strong><code>n()</code></strong>,
that counts the number of rows rather than computing a summary value
from one of the columns.</p>
<pre class="r"><code>metabric %&gt;%
    summarise(N = n(), ESR1_mean = mean(ESR1), .by = c(PAM50, HER2_status))</code></pre>
<pre><code>## # A tibble: 13 × 4
##    PAM50       HER2_status     N ESR1_mean
##    &lt;chr&gt;       &lt;chr&gt;       &lt;int&gt;     &lt;dbl&gt;
##  1 claudin-low Negative      184      7.52
##  2 LumA        Negative      658     10.8 
##  3 LumB        Negative      419     11.1 
##  4 Her2        Negative       95      8.82
##  5 LumA        Positive       21     10.1 
##  6 claudin-low Positive       15      6.80
##  7 Normal      Negative      127      9.68
##  8 Basal       Negative      179      6.39
##  9 Her2        Positive      125      7.04
## 10 LumB        Positive       42     10.2 
## 11 Basal       Positive       20      6.71
## 12 Normal      Positive       13      7.77
## 13 NC          Negative        6     10.9</code></pre>
</div>
<div id="counts" class="section level2">
<h2>Counts</h2>
<p>Counting observations within groups is such a common operation that
dplyr provides a <strong><code>count()</code></strong> function to do
just that. So we could count the number of patient samples in each of
the PAM50 classes as follows.</p>
<pre class="r"><code>count(metabric, PAM50)</code></pre>
<pre><code>## # A tibble: 7 × 2
##   PAM50           n
##   &lt;chr&gt;       &lt;int&gt;
## 1 Basal         199
## 2 Her2          220
## 3 LumA          679
## 4 LumB          461
## 5 NC              6
## 6 Normal        140
## 7 claudin-low   199</code></pre>
<p>This is much like the <code>table()</code> function we’ve used
several times already to take a quick look at what values are contained
in one of the columns in a data frame. They return different data
structures however, with <code>count()</code> always returning a data
frame (or tibble) that can then be passed to subsequent steps in a
‘piped’ workflow.</p>
<p>If we wanted to subdivide our categories by HER2 status, we can add
this as an additional categorical variable just as we did with the
previous <code>group_by()</code> examples.</p>
<pre class="r"><code>count(metabric, PAM50, HER2_status)</code></pre>
<pre><code>## # A tibble: 13 × 3
##    PAM50       HER2_status     n
##    &lt;chr&gt;       &lt;chr&gt;       &lt;int&gt;
##  1 Basal       Negative      179
##  2 Basal       Positive       20
##  3 Her2        Negative       95
##  4 Her2        Positive      125
##  5 LumA        Negative      658
##  6 LumA        Positive       21
##  7 LumB        Negative      419
##  8 LumB        Positive       42
##  9 NC          Negative        6
## 10 Normal      Negative      127
## 11 Normal      Positive       13
## 12 claudin-low Negative      184
## 13 claudin-low Positive       15</code></pre>
<p>The count column is named ‘n’ by default but you can change this.</p>
<pre class="r"><code>count(metabric, PAM50, HER2_status, name = &quot;Samples&quot;)</code></pre>
<pre><code>## # A tibble: 13 × 3
##    PAM50       HER2_status Samples
##    &lt;chr&gt;       &lt;chr&gt;         &lt;int&gt;
##  1 Basal       Negative        179
##  2 Basal       Positive         20
##  3 Her2        Negative         95
##  4 Her2        Positive        125
##  5 LumA        Negative        658
##  6 LumA        Positive         21
##  7 LumB        Negative        419
##  8 LumB        Positive         42
##  9 NC          Negative          6
## 10 Normal      Negative        127
## 11 Normal      Positive         13
## 12 claudin-low Negative        184
## 13 claudin-low Positive         15</code></pre>
<p><code>count()</code> is equivalent to grouping observations calling
<code>summarize()</code> using the special <code>n()</code> function to
count the number of rows. So the above statement could have been written
in a more long-winded way as follows.</p>
<pre class="r"><code>metabric %&gt;%
    summarize(Samples = n(), .by = c(PAM50, HER2_status))</code></pre>
<p>Summarizing with <code>n()</code> is useful when showing the number
of observations in a group alongside a summary value, as we did earlier
looking at the mean ESR1 expression within specified groups; it allows
you to see if you’re drawing conclusions from only a few data
points.</p>
</div>
<div id="missing-values" class="section level2">
<h2>Missing values</h2>
<p>Many summarization functions return <code>NA</code> if any of the
values are missing, i.e. the column contains <code>NA</code> values. As
an example, we’ll compute the average size of ER-negative and
ER-positive tumours.</p>
<pre class="r"><code>metabric %&gt;%
    summarize(N = n(),
              `Average tumour size` = mean(Tumour_size),
              .by = ER_status)</code></pre>
<pre><code>## # A tibble: 2 × 3
##   ER_status     N `Average tumour size`
##   &lt;chr&gt;     &lt;int&gt;                 &lt;dbl&gt;
## 1 Positive   1459                    NA
## 2 Negative    445                    NA</code></pre>
<p>The <code>mean()</code> function, along with many similar
summarization functions, has an <code>na.rm</code> argument that can be
set to <code>TRUE</code> to exclude those missing values from the
calculation.</p>
<pre class="r"><code>metabric %&gt;%
    summarize(N = n(),
              `Average tumour size` = mean(Tumour_size, na.rm = TRUE),
              .by = ER_status)</code></pre>
<pre><code>## # A tibble: 2 × 3
##   ER_status     N `Average tumour size`
##   &lt;chr&gt;     &lt;int&gt;                 &lt;dbl&gt;
## 1 Positive   1459                  25.6
## 2 Negative    445                  28.5</code></pre>
<p>An alternative would be to filter out the observations with missing
values but then the number of samples in each ER status group would take
on a different meaning, which may or may not be what we actually
want.</p>
<pre class="r"><code>metabric %&gt;%
    filter(!is.na(Tumour_size)) %&gt;%
    summarize(N = n(),
              `Average tumour size` = mean(Tumour_size),
              .by = ER_status)</code></pre>
<pre><code>## # A tibble: 2 × 3
##   ER_status     N `Average tumour size`
##   &lt;chr&gt;     &lt;int&gt;                 &lt;dbl&gt;
## 1 Positive   1446                  25.6
## 2 Negative    438                  28.5</code></pre>
</div>
<div id="counts-and-proportions" class="section level2">
<h2>Counts and proportions</h2>
<p>The <code>sum()</code> and <code>mean()</code> summarization
functions are often used with logical values. It might seem surprising
to compute a summary for a logical variable but but this turns out to be
quite a useful thing to do, for counting the number of <code>TRUE</code>
values or obtaining the proportion of values that are
<code>TRUE</code>.</p>
<p>Following on from the previous example we could add a column to our
summary of average tumour size for ER-positive and ER-negative patients
that contains the number of missing values.</p>
<pre class="r"><code>metabric %&gt;%
    summarize(N = n(),
              Missing = sum(is.na(Tumour_size)),
              `Average tumour size` = mean(Tumour_size, na.rm = TRUE),
              .by = ER_status)</code></pre>
<pre><code>## # A tibble: 2 × 4
##   ER_status     N Missing `Average tumour size`
##   &lt;chr&gt;     &lt;int&gt;   &lt;int&gt;                 &lt;dbl&gt;
## 1 Positive   1459      13                  25.6
## 2 Negative    445       7                  28.5</code></pre>
<p>Why does this work? Well, the <code>is.na()</code> function takes a
vector and sees which values are <code>NA</code>, returning a logical
vector of <code>TRUE</code> where the value was <code>NA</code> and
<code>FALSE</code> if not.</p>
<pre class="r"><code>test_vector &lt;- c(1, 3, 2, NA, 6, 5, NA, 10)
is.na(test_vector)</code></pre>
<pre><code>## [1] FALSE FALSE FALSE  TRUE FALSE FALSE  TRUE FALSE</code></pre>
<p>The <code>sum()</code> function treats the logical vector as a set of
<code>0</code>s and <code>1</code>s where <code>FALSE</code> is
<code>0</code> and <code>TRUE</code> is <code>1</code>. In effect
<code>sum()</code> counts the number of <code>TRUE</code> values.</p>
<pre class="r"><code>sum(is.na(test_vector))</code></pre>
<pre><code>## [1] 2</code></pre>
<p>Similarly, <code>mean()</code> will compute the proportion of the
values that are <code>TRUE</code>.</p>
<pre class="r"><code>mean(is.na(test_vector))</code></pre>
<pre><code>## [1] 0.25</code></pre>
<p>So let’s calculate the number and proportion of samples that do not
have a recorded tumour size in each of the ER-negative and ER-positive
groups.</p>
<pre class="r"><code>metabric %&gt;%
    summarize(N = n(),
              `Missing tumour size` = sum(is.na(Tumour_size)),
              `Proportion missing` = mean(is.na(Tumour_size)),
              .by = ER_status)</code></pre>
<pre><code>## # A tibble: 2 × 4
##   ER_status     N `Missing tumour size` `Proportion missing`
##   &lt;chr&gt;     &lt;int&gt;                 &lt;int&gt;                &lt;dbl&gt;
## 1 Positive   1459                    13              0.00891
## 2 Negative    445                     7              0.0157</code></pre>
<p>We can use <code>sum()</code> and <code>mean()</code> for any
condition that returns a logical vector. We could, for example, find the
number and proportion of patients that survived longer than 10 years
(120 months) in each of the ER-negative and ER-positive groups.</p>
<pre class="r"><code>metabric %&gt;%
    filter(Survival_status == &quot;DECEASED&quot;) %&gt;%
    summarise(N = n(),
              N_long_survival = sum(Survival_time &gt; 120),
              Proportion_long_survival = mean(Survival_time &gt; 120),
              .by = ER_status)</code></pre>
<pre><code>## # A tibble: 2 × 4
##   ER_status     N N_long_survival Proportion_long_survival
##   &lt;chr&gt;     &lt;int&gt;           &lt;int&gt;                    &lt;dbl&gt;
## 1 Positive    853             325                    0.381
## 2 Negative    250              40                    0.16</code></pre>
</div>
<div id="selecting-or-counting-distinct-things" class="section level2">
<h2>Selecting or counting distinct things</h2>
<p>There are occassions when we want to count the number of distinct
values in a variable or a combination of variables. Here we introduce
another set of data from the METABRIC study which contains details of
the mutations detected by targeted sequencing of a panel of 173 genes.
We’ll read this data into R now as this provides a good example of
having multiple observations in different rows for a single
observational unit, in this case several mutations detected in each
tumour sample.</p>
<pre class="r"><code>mutations &lt;- read_csv(&quot;data/metabric_mutations.csv&quot;)

select(mutations,
       Patient_ID,
       Chromosome,
       Position = Start_Position,
       Ref = Reference_Allele,
       Alt = Tumor_Seq_Allele1,
       Type = Variant_Type,
       Gene)</code></pre>
<pre><code>## # A tibble: 17,272 × 7
##    Patient_ID Chromosome  Position Ref   Alt   Type  Gene 
##    &lt;chr&gt;      &lt;chr&gt;          &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;
##  1 MTS-T0058  17           7579344 &lt;NA&gt;  &lt;NA&gt;  INS   TP53 
##  2 MTS-T0058  17           7579346 &lt;NA&gt;  &lt;NA&gt;  INS   TP53 
##  3 MTS-T0058  6          168299111 G     G     SNP   MLLT4
##  4 MTS-T0058  22          29999995 G     G     SNP   NF2  
##  5 MTS-T0059  2          198288682 A     A     SNP   SF3B1
##  6 MTS-T0059  6           86195125 T     T     SNP   NT5E 
##  7 MTS-T0059  7           55241717 C     C     SNP   EGFR 
##  8 MTS-T0059  10           6556986 C     C     SNP   PRKCQ
##  9 MTS-T0059  11          62300529 T     T     SNP   AHNAK
## 10 MTS-T0059  15          74912475 G     G     SNP   CLK3 
## # ℹ 17,262 more rows</code></pre>
<p>We can see from just these few rows that each patient sample has
multiple mutations and sometimes there are more than one mutation in the
same gene within a sample, as can be seen in the first two rows at the
top of the table above.</p>
<p>If we want to count the number of patients in which mutations were
detected we could select the distinct set of patient identifiers using
the <strong><code>distinct()</code></strong> function and then count the
number of rows left. Distinct reduces the table to ony contain one row
for each value of the column (or combination of columns) provided:</p>
<pre class="r"><code>mutations %&gt;%
    distinct(Patient_ID) %&gt;%
    nrow()</code></pre>
<pre><code>## [1] 2369</code></pre>
<p>However, if we want to count the number of mutations per a patient we
can use the dplyr function <strong><code>count()</code></strong>:</p>
<pre class="r"><code>count(mutations, Patient_ID)</code></pre>
<pre><code>## # A tibble: 2,369 × 2
##    Patient_ID     n
##    &lt;chr&gt;      &lt;int&gt;
##  1 MB-0002        2
##  2 MB-0005        2
##  3 MB-0006        1
##  4 MB-0008        4
##  5 MB-0010        4
##  6 MB-0014        6
##  7 MB-0022        1
##  8 MB-0025        7
##  9 MB-0028        4
## 10 MB-0035        7
## # ℹ 2,359 more rows</code></pre>
<p>Similarly if wanted to count the number of mutations detected in each
gene:</p>
<pre class="r"><code>count(mutations, Gene)</code></pre>
<pre><code>## # A tibble: 173 × 2
##    Gene       n
##    &lt;chr&gt;  &lt;int&gt;
##  1 ACVRL1    20
##  2 AFF2      70
##  3 AGMO      43
##  4 AGTR2     14
##  5 AHNAK    327
##  6 AHNAK2   859
##  7 AKAP9    182
##  8 AKT1     115
##  9 AKT2      23
## 10 ALK       98
## # ℹ 163 more rows</code></pre>
<p>What if we want to count the number of patients in which a mutation
is seen for each gene. First, we need to use
<strong><code>distinct()</code></strong> to reduce the table to just one
entry per gene for each patient (one patient may have multiple mutations
in a single gene) and the use <strong><code>count()</code></strong> to
count the number of times we see each each.</p>
<pre class="r"><code>mutations %&gt;%
    distinct(Patient_ID, Gene) %&gt;%
    count(Gene)</code></pre>
<pre><code>## # A tibble: 173 × 2
##    Gene       n
##    &lt;chr&gt;  &lt;int&gt;
##  1 ACVRL1    20
##  2 AFF2      69
##  3 AGMO      43
##  4 AGTR2     14
##  5 AHNAK    272
##  6 AHNAK2   530
##  7 AKAP9    173
##  8 AKT1     115
##  9 AKT2      23
## 10 ALK       95
## # ℹ 163 more rows</code></pre>
<p>The genes that differ in these two tables are those that have more
than one mutation within a patient tumour sample.</p>
<p>We can also use count on combinations of columns, for example we may
want to know how many mutations each patient has on each chromosome. To
this we simply provide <strong><code>count()</code></strong> with both
columns:</p>
<pre class="r"><code>mutations %&gt;%
    count(Patient_ID, Chromosome)</code></pre>
<pre><code>## # A tibble: 13,127 × 3
##    Patient_ID Chromosome     n
##    &lt;chr&gt;      &lt;chr&gt;      &lt;int&gt;
##  1 MB-0002    17             1
##  2 MB-0002    6              1
##  3 MB-0005    17             1
##  4 MB-0005    3              1
##  5 MB-0006    3              1
##  6 MB-0008    17             1
##  7 MB-0008    2              1
##  8 MB-0008    3              1
##  9 MB-0008    8              1
## 10 MB-0010    10             1
## # ℹ 13,117 more rows</code></pre>
</div>
</div>
<div id="joining-data" class="section level1">
<h1>Joining data</h1>
<p>In many real life situations, data are spread across multiple tables
or spreadsheets. Usually this occurs because different types of
information about a subject, e.g. a patient, are collected from
different sources. It may be desirable for some analyses to combine data
from two or more tables into a single data frame based on a common
column, for example, an attribute that uniquely identifies the subject
such as a patient identifier.</p>
<p>dplyr provides a set of join functions for combining two data frames
based on matches within specified columns. These operations are very
similar to carrying out join operations between tables in a relational
database using SQL.</p>
<div id="left_join" class="section level2">
<h2><code>left_join</code></h2>
<p>To illustrate join operations we’ll first consider the most common
type, a “left join”. In the schematic below the two data frames share a
common column, V1. We can combine the two data frames into a single data
frame by matching rows in the first data frame with those in the second
data frame that share the same value of variable V1.</p>
<div class="float">
<img src="images/dplyr_left_join.png" alt="dplyr left join" />
<div class="figcaption">dplyr left join</div>
</div>
<p><code>left_join()</code> returns all rows from the first data frame
regardless of whether there is a match in the second data frame. Rows
with no match are included in the resulting data frame but have
<code>NA</code> values in the additional columns coming from the second
data frame.</p>
<p>Here’s an example in which details about members of the Beatles and
Rolling Stones are contained in two tables, using data frames
conveniently provided by dplyr (we’ll look at a real example
shortly).</p>
<p>The name column identifies each of the band members and is used for
matching rows from the two tables.</p>
<pre class="r"><code>band_members</code></pre>
<pre><code>## # A tibble: 3 × 2
##   name  band   
##   &lt;chr&gt; &lt;chr&gt;  
## 1 Mick  Stones 
## 2 John  Beatles
## 3 Paul  Beatles</code></pre>
<pre class="r"><code>band_instruments</code></pre>
<pre><code>## # A tibble: 3 × 2
##   name  plays 
##   &lt;chr&gt; &lt;chr&gt; 
## 1 John  guitar
## 2 Paul  bass  
## 3 Keith guitar</code></pre>
<pre class="r"><code>left_join(band_members, band_instruments, by = &quot;name&quot;)</code></pre>
<pre><code>## # A tibble: 3 × 3
##   name  band    plays 
##   &lt;chr&gt; &lt;chr&gt;   &lt;chr&gt; 
## 1 Mick  Stones  &lt;NA&gt;  
## 2 John  Beatles guitar
## 3 Paul  Beatles bass</code></pre>
<p>We have joined the band members and instruments tables based on the
common <code>name</code> column. Because this is a left join, only
observations for band members in the ‘left’ table
(<code>band_members</code>) are included with information brought in
from the ‘right’ table (<code>band_instruments</code>) where such
exists. There is no entry in <code>band_instruments</code> for Mick so
an <code>NA</code> value is inserted into the <code>plays</code> column
that gets added in the combined data frame. Keith is only included in
the <code>band_instruments</code> data frame so doesn’t make it into the
final output as this is based on those band members in the ‘left’
table.</p>
<p><code>right_join()</code> is similar but returns all rows from the
second data frame, i.e. the ‘right’ data frame, that have a match with
rows in the first data frame.</p>
<pre class="r"><code>right_join(band_members, band_instruments, by = &quot;name&quot;)</code></pre>
<pre><code>## # A tibble: 3 × 3
##   name  band    plays 
##   &lt;chr&gt; &lt;chr&gt;   &lt;chr&gt; 
## 1 John  Beatles guitar
## 2 Paul  Beatles bass  
## 3 Keith &lt;NA&gt;    guitar</code></pre>
<p><code>right_join()</code> is used very infrequently compared with
<code>left_join()</code>.</p>
</div>
<div id="inner_join" class="section level2">
<h2><code>inner_join</code></h2>
<p>Another joining operation is the “inner join” in which only
observations that are common to both data frames are included.</p>
<div class="float">
<img src="images/dplyr_inner_join.png" alt="dplyr inner join" />
<div class="figcaption">dplyr inner join</div>
</div>
<pre class="r"><code>inner_join(band_members, band_instruments, by = &quot;name&quot;)</code></pre>
<pre><code>## # A tibble: 2 × 3
##   name  band    plays 
##   &lt;chr&gt; &lt;chr&gt;   &lt;chr&gt; 
## 1 John  Beatles guitar
## 2 Paul  Beatles bass</code></pre>
<p>In this case when considering observations identified by
<code>name</code>, only John and Paul are contained in both the
<code>band_members</code> and <code>band_instruments</code> tables, so
only these make it into the combined table.</p>
</div>
<div id="full_join" class="section level2">
<h2><code>full_join</code></h2>
<p>We’ve seen how missing rows from one table can be retained in the
joined data frame using <code>left_join</code> or
<code>right_join</code> but sometimes data for a given subject may be
missing from either of the tables and we still want that subject to
appear in the combined table. A <code>full_join</code> will return all
rows and all columns from the two tables and where there are no matching
values, <code>NA</code> values are used to fill in the missing
values.</p>
<div class="float">
<img src="images/dplyr_full_join.png" alt="dplyr full join" />
<div class="figcaption">dplyr full join</div>
</div>
<pre class="r"><code>full_join(band_members, band_instruments, by = &quot;name&quot;)</code></pre>
<pre><code>## # A tibble: 4 × 3
##   name  band    plays 
##   &lt;chr&gt; &lt;chr&gt;   &lt;chr&gt; 
## 1 Mick  Stones  &lt;NA&gt;  
## 2 John  Beatles guitar
## 3 Paul  Beatles bass  
## 4 Keith &lt;NA&gt;    guitar</code></pre>
<p>Now, with <code>full_join()</code>, we have rows for both Mick and
Keith even though they are only in one or other of the tables being
joined.</p>
</div>
<div id="joining-on-columns-with-different-headers"
class="section level2">
<h2>Joining on columns with different headers</h2>
<p>It isn’t uncommon for the columns used for joining two tables to have
different names in each table. Of course we could rename one of the two
columns, e.g. using the dplyr <code>rename()</code> function, but the
dplyr join functions allow you to match using differently-named columns
as illustrated using another version of the
<code>band_instruments</code> data frame.</p>
<pre class="r"><code>band_instruments2</code></pre>
<pre><code>## # A tibble: 3 × 2
##   artist plays 
##   &lt;chr&gt;  &lt;chr&gt; 
## 1 John   guitar
## 2 Paul   bass  
## 3 Keith  guitar</code></pre>
<pre class="r"><code>left_join(band_members, band_instruments2, by = c(&quot;name&quot; = &quot;artist&quot;))</code></pre>
<pre><code>## # A tibble: 3 × 3
##   name  band    plays 
##   &lt;chr&gt; &lt;chr&gt;   &lt;chr&gt; 
## 1 Mick  Stones  &lt;NA&gt;  
## 2 John  Beatles guitar
## 3 Paul  Beatles bass</code></pre>
<p>The name for the column used for joining is the one given in the
first table, i.e. the ‘left’ table, so <code>name</code> rather than
<code>artist</code> in this case.</p>
</div>
<div id="multiple-matches-in-join-operations" class="section level2">
<h2>Multiple matches in join operations</h2>
<p>You may be wondering what happens if there are multiple rows in one
of both of the two tables for the thing that is being joined, for
example what would happen if our second table had two entries for
instruments that Paul plays.</p>
<p>Let’s add an extra intrument for Paul and see what happens when we
join the two tables. We’ll use the <code>bind_rows()</code> function to
add a row to the <code>band_instruments</code> tibble.</p>
<pre class="r"><code>extra_instrument &lt;- tibble(name = &quot;Paul&quot;, plays = &quot;guitar&quot;)
band_instruments3 &lt;- bind_rows(band_instruments, extra_instrument) 
band_instruments3</code></pre>
<pre><code>## # A tibble: 4 × 2
##   name  plays 
##   &lt;chr&gt; &lt;chr&gt; 
## 1 John  guitar
## 2 Paul  bass  
## 3 Keith guitar
## 4 Paul  guitar</code></pre>
<pre class="r"><code>left_join(band_members, band_instruments3, by = &quot;name&quot;)</code></pre>
<pre><code>## # A tibble: 4 × 3
##   name  band    plays 
##   &lt;chr&gt; &lt;chr&gt;   &lt;chr&gt; 
## 1 Mick  Stones  &lt;NA&gt;  
## 2 John  Beatles guitar
## 3 Paul  Beatles bass  
## 4 Paul  Beatles guitar</code></pre>
<p>We get both entries from the second table added to the first
table.</p>
<p>Let’s add an entry for Paul being in a second band and see what
happens then when we combine the two tables, each with two entries for
Paul.</p>
<pre class="r"><code>extra_band &lt;- tibble(name = &quot;Paul&quot;, band = &quot;Wings&quot;)
band_members3 &lt;- bind_rows(band_members, extra_band)
band_members3</code></pre>
<pre><code>## # A tibble: 4 × 2
##   name  band   
##   &lt;chr&gt; &lt;chr&gt;  
## 1 Mick  Stones 
## 2 John  Beatles
## 3 Paul  Beatles
## 4 Paul  Wings</code></pre>
<pre class="r"><code>left_join(band_members3, band_instruments3, by = &quot;name&quot;)</code></pre>
<pre><code>## Warning in left_join(band_members3, band_instruments3, by = &quot;name&quot;): Detected an unexpected many-to-many relationship between `x` and `y`.
## ℹ Row 3 of `x` matches multiple rows in `y`.
## ℹ Row 2 of `y` matches multiple rows in `x`.
## ℹ If a many-to-many relationship is expected, set `relationship =
##   &quot;many-to-many&quot;` to silence this warning.</code></pre>
<pre><code>## # A tibble: 6 × 3
##   name  band    plays 
##   &lt;chr&gt; &lt;chr&gt;   &lt;chr&gt; 
## 1 Mick  Stones  &lt;NA&gt;  
## 2 John  Beatles guitar
## 3 Paul  Beatles bass  
## 4 Paul  Beatles guitar
## 5 Paul  Wings   bass  
## 6 Paul  Wings   guitar</code></pre>
<p>The resulting table includes all combinations of band and instrument
for Paul.</p>
</div>
<div id="joining-by-matching-on-multiple-columns"
class="section level2">
<h2>Joining by matching on multiple columns</h2>
<p>Sometimes the observations being combined are identified by multiple
columns, for example, a forename and a surname. We can specify a vector
of column names to be used in the join operation.</p>
<p>Let’s add surnames and an additional band member to the
<code>band_members</code> and <code>band_instruments</code> tables and
then join the two tables based on both forename and surname. We’ll also
use <code>rename</code> to change the column name <code>name</code> to
<code>forename</code>.</p>
<pre class="r"><code>extra_musician &lt;- tibble(forename = &quot;Paul&quot;,
                         surname = &quot;Weller&quot;,
                         band = &quot;The Jam&quot;)
band_members4 &lt;- band_members %&gt;%
    rename(forename = name) %&gt;%
    mutate(surname = c(&quot;Jagger&quot;, &quot;Lennon&quot;, &quot;McCartney&quot;)) %&gt;%
    bind_rows(extra_musician) %&gt;%
    select(forename, surname, band)

extra_instrument &lt;- tibble(forename = &quot;Paul&quot;,
                           surname = &quot;Weller&quot;,
                           plays = &quot;guitar&quot;)
band_instruments4 &lt;- band_instruments %&gt;%
    rename(forename = name) %&gt;%
    mutate(surname = c(&quot;Lennon&quot;, &quot;McCartney&quot;, &quot;Richards&quot;)) %&gt;%
    bind_rows(extra_instrument) %&gt;%
    select(forename, surname, plays)

band_members4</code></pre>
<pre><code>## # A tibble: 4 × 3
##   forename surname   band   
##   &lt;chr&gt;    &lt;chr&gt;     &lt;chr&gt;  
## 1 Mick     Jagger    Stones 
## 2 John     Lennon    Beatles
## 3 Paul     McCartney Beatles
## 4 Paul     Weller    The Jam</code></pre>
<pre class="r"><code>band_instruments4</code></pre>
<pre><code>## # A tibble: 4 × 3
##   forename surname   plays 
##   &lt;chr&gt;    &lt;chr&gt;     &lt;chr&gt; 
## 1 John     Lennon    guitar
## 2 Paul     McCartney bass  
## 3 Keith    Richards  guitar
## 4 Paul     Weller    guitar</code></pre>
<pre class="r"><code>full_join(band_members4, band_instruments4, by = c(&quot;forename&quot;, &quot;surname&quot;))</code></pre>
<pre><code>## # A tibble: 5 × 4
##   forename surname   band    plays 
##   &lt;chr&gt;    &lt;chr&gt;     &lt;chr&gt;   &lt;chr&gt; 
## 1 Mick     Jagger    Stones  &lt;NA&gt;  
## 2 John     Lennon    Beatles guitar
## 3 Paul     McCartney Beatles bass  
## 4 Paul     Weller    The Jam guitar
## 5 Keith    Richards  &lt;NA&gt;    guitar</code></pre>
</div>
<div id="clashing-column-names" class="section level2">
<h2>Clashing column names</h2>
<p>Occasionally we may find that there are duplicated columns in the two
tables we want to join, columns that aren’t those used for joining.
These variables may even contain different data but happen to have the
same name. In such cases dplyr joins add a suffix to each column in the
combined table.</p>
<pre class="r"><code>band_members5 &lt;- band_members %&gt;%
    mutate(birth_year = c(1943, 1940, 1942))
band_instruments5 &lt;- band_instruments %&gt;%
    mutate(birth_year = c(1940, 1942, 1943))
left_join(band_members5, band_instruments5, by = &quot;name&quot;)</code></pre>
<pre><code>## # A tibble: 3 × 5
##   name  band    birth_year.x plays  birth_year.y
##   &lt;chr&gt; &lt;chr&gt;          &lt;dbl&gt; &lt;chr&gt;         &lt;dbl&gt;
## 1 Mick  Stones          1943 &lt;NA&gt;             NA
## 2 John  Beatles         1940 guitar         1940
## 3 Paul  Beatles         1942 bass           1942</code></pre>
<p>It is advisable to rename or remove the duplicated columns that
aren’t used for joining.</p>
</div>
<div
id="a-real-example-joining-the-metabric-clinical-and-mrna-expression-data"
class="section level2">
<h2>A real example: joining the METABRIC clinical and mRNA expression
data</h2>
<p>Let’s move on to a real example of joining data from two different
tables that we used in putting together the combined METABRIC clinical
and expression data set.</p>
<p>We first read the clinical data into R and then just select a small
number of columns to make it easier to see what is going on when
combining the data.</p>
<pre class="r"><code>clinical_data &lt;- read_csv(&quot;data/metabric_clinical_data.csv&quot;)
clinical_data &lt;- select(clinical_data, Patient_ID, ER_status, PAM50)
clinical_data</code></pre>
<pre><code>## # A tibble: 2,509 × 3
##    Patient_ID ER_status PAM50      
##    &lt;chr&gt;      &lt;chr&gt;     &lt;chr&gt;      
##  1 MB-0000    Positive  claudin-low
##  2 MB-0002    Positive  LumA       
##  3 MB-0005    Positive  LumB       
##  4 MB-0006    Positive  LumB       
##  5 MB-0008    Positive  LumB       
##  6 MB-0010    Positive  LumB       
##  7 MB-0014    Positive  LumB       
##  8 MB-0020    Negative  Normal     
##  9 MB-0022    Positive  claudin-low
## 10 MB-0025    Positive  &lt;NA&gt;       
## # ℹ 2,499 more rows</code></pre>
<p>We then read in the mRNA expression data that was downloaded
separately from <a
href="https://www.cbioportal.org/study/summary?id=brca_metabric">cBioPortal</a>.</p>
<pre class="r"><code>mrna_expression_data &lt;- read_tsv(&quot;data/metabric_mrna_expression.txt&quot;)
mrna_expression_data</code></pre>
<pre><code>## # A tibble: 2,509 × 10
##    STUDY_ID      SAMPLE_ID  ESR1 ERBB2   PGR  TP53 PIK3CA GATA3 FOXA1  MLPH
##    &lt;chr&gt;         &lt;chr&gt;     &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;
##  1 brca_metabric MB-0000    8.93  9.33  5.68  6.34   5.70  6.93  7.95  9.73
##  2 brca_metabric MB-0002   10.0   9.73  7.51  6.19   5.76 11.3  11.8  12.5 
##  3 brca_metabric MB-0005   10.0   9.73  7.38  6.40   6.75  9.29 11.7  10.3 
##  4 brca_metabric MB-0006   10.4  10.3   6.82  6.87   7.22  8.67 11.9  10.5 
##  5 brca_metabric MB-0008   11.3   9.96  7.33  6.34   5.82  9.72 11.6  12.2 
##  6 brca_metabric MB-0010   11.2   9.74  5.95  5.42   6.12  9.79 12.1  11.4 
##  7 brca_metabric MB-0014   10.8   9.28  7.72  5.99   7.48  8.37 11.5  10.8 
##  8 brca_metabric MB-0020   NA    NA    NA    NA     NA    NA    NA    NA   
##  9 brca_metabric MB-0022   10.4   8.61  5.59  6.17   7.59  7.87 10.7   9.95
## 10 brca_metabric MB-0025   NA    NA    NA    NA     NA    NA    NA    NA   
## # ℹ 2,499 more rows</code></pre>
<p>Now we have both sets of data loaded into R as data frames, we can
combine them into a single data frame using an
<code>inner_join()</code>. Our resulting table will only contain entries
for the patients for which expression data are available.</p>
<pre class="r"><code>combined_data &lt;- inner_join(clinical_data,
                            mrna_expression_data,
                            by = c(&quot;Patient_ID&quot; = &quot;SAMPLE_ID&quot;))
combined_data</code></pre>
<pre><code>## # A tibble: 2,509 × 12
##    Patient_ID ER_status PAM50      STUDY_ID  ESR1 ERBB2   PGR  TP53 PIK3CA GATA3
##    &lt;chr&gt;      &lt;chr&gt;     &lt;chr&gt;      &lt;chr&gt;    &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt;
##  1 MB-0000    Positive  claudin-l… brca_me…  8.93  9.33  5.68  6.34   5.70  6.93
##  2 MB-0002    Positive  LumA       brca_me… 10.0   9.73  7.51  6.19   5.76 11.3 
##  3 MB-0005    Positive  LumB       brca_me… 10.0   9.73  7.38  6.40   6.75  9.29
##  4 MB-0006    Positive  LumB       brca_me… 10.4  10.3   6.82  6.87   7.22  8.67
##  5 MB-0008    Positive  LumB       brca_me… 11.3   9.96  7.33  6.34   5.82  9.72
##  6 MB-0010    Positive  LumB       brca_me… 11.2   9.74  5.95  5.42   6.12  9.79
##  7 MB-0014    Positive  LumB       brca_me… 10.8   9.28  7.72  5.99   7.48  8.37
##  8 MB-0020    Negative  Normal     brca_me… NA    NA    NA    NA     NA    NA   
##  9 MB-0022    Positive  claudin-l… brca_me… 10.4   8.61  5.59  6.17   7.59  7.87
## 10 MB-0025    Positive  &lt;NA&gt;       brca_me… NA    NA    NA    NA     NA    NA   
## # ℹ 2,499 more rows
## # ℹ 2 more variables: FOXA1 &lt;dbl&gt;, MLPH &lt;dbl&gt;</code></pre>
<p>Having combined the data, we can carry out exploratory data analysis
using elements from both data sets.</p>
<pre class="r"><code>combined_data %&gt;%
    filter(!is.na(PAM50), !is.na(ESR1)) %&gt;%
    ggplot(mapping = aes(x = PAM50, y = ESR1, colour = PAM50)) +
    geom_boxplot(show.legend = FALSE)</code></pre>
<p><img src="week6_files/figure-html/box_plot_1-1.png" width="672" /></p>
</div>
</div>
<div id="customizing-plots-with-ggplot2" class="section level1">
<h1>Customizing plots with ggplot2</h1>
<p>Finally, we’ll turn our attention back to visualization using ggplot2
and how we can customize our plots by adding or changing titles and
labels, changing the scales used on the x and y axes, and choosing
colours.</p>
<div id="titles-and-labels" class="section level2">
<h2>Titles and labels</h2>
<p>Adding titles and subtitles to a plot and changing the x- and y-axis
labels is very straightforward using the <code>labs()</code>
function.</p>
<pre class="r"><code>ggplot(metabric, mapping = aes(x = GATA3, y = ESR1, colour = ER_status)) +
    geom_point(size = 0.6, alpha = 0.5) +
    geom_smooth(method = &quot;lm&quot;) +
    labs(title = &quot;mRNA expression in the METABRIC breast cancer data set&quot;,
         subtitle = &quot;Expression measured with Illumina bead arrays&quot;,
         x = &quot;log2 GATA3 expression&quot;,
         y = &quot;log2 ESR1 expression&quot;,
         colour = &quot;ER status&quot;)</code></pre>
<pre><code>## `geom_smooth()` using formula = &#39;y ~ x&#39;</code></pre>
<p><img src="week6_files/figure-html/scatter_plot_1-1.png" width="672" /></p>
<p>The labels are another component of the plot object that we’ve
constructed, along with aesthetic mappings and layers (geoms). The plot
object is a list and contains various elements including those mappings
and layers and one element named <code>labels</code>.</p>
<p><code>labs()</code> is a simple function for creating a list of
labels you want to specify as name-value pairs as in the above example.
You can name any aesthetic (in this case x and y) to override the
default values (the column names) and you can add a title, subtitle and
caption if you wish. In addition to changing the x- and y-axis labels,
we also removed the underscore from the legend title by setting the
label for the colour aesthetic.</p>
</div>
<div id="scales" class="section level2">
<h2>Scales</h2>
<p>Take a look at the x and y scales in the above plot. ggplot2 has
chosen the x and y scales and where to put breaks and ticks.</p>
<p>The x and y variables (<code>GATA3</code> and <code>ESR1</code>) are
continuous so ggplot2 adds a continuous scale for each.
<code>ER_status</code> is a discrete variable in this case so ggplot2
adds a discrete scale for colour.</p>
<p>In addition to <em>geom_XXXX</em> layers for different geometries, we
can also add use scale layers to modify the scales to our liking. The
general format for the scale names is:</p>
<pre><code>scale_&lt;NAME_OF_AESTHETIC&gt;_&lt;NAME_OF_SCALE&gt;</code></pre>
<p>Look at the help page for <code>scale_y_continuous</code> to see what
we can change about the y-axis scale.</p>
<p>First we’ll change the breaks, i.e. where ggplot2 puts ticks and
numeric labels, on the y axis.</p>
<pre class="r"><code>ggplot(data = metabric,
       mapping = aes(x = GATA3, y = ESR1, colour = ER_status)) +
    geom_point(size = 0.6, alpha = 0.5) +
    geom_smooth(method = &quot;lm&quot;) +
    scale_y_continuous(breaks = seq(5, 15, by = 2.5))</code></pre>
<pre><code>## `geom_smooth()` using formula = &#39;y ~ x&#39;</code></pre>
<p><img src="week6_files/figure-html/scatter_plot_2-1.png" width="672" /></p>
<p><code>seq()</code> is a useful function for generating regular
sequences of numbers. In this case we wanted numbers from 5 to 15 going
up in steps of 2.5.</p>
<pre class="r"><code>seq(5, 15, by = 2.5)</code></pre>
<pre><code>## [1]  5.0  7.5 10.0 12.5 15.0</code></pre>
<p>We could do the same thing for the x axis using
<code>scale_x_continuous()</code>.</p>
<p>We can also adjust the extents of the x or y axis.</p>
<pre class="r"><code>ggplot(data = metabric,
       mapping = aes(x = GATA3, y = ESR1, colour = ER_status)) +
    geom_point(size = 0.6, alpha = 0.5) +
    geom_smooth(method = &quot;lm&quot;) +
    scale_y_continuous(breaks = seq(5, 15, by = 2.5), limits = c(4, 12))</code></pre>
<pre><code>## `geom_smooth()` using formula = &#39;y ~ x&#39;</code></pre>
<pre><code>## Warning: Removed 160 rows containing non-finite outside the scale range
## (`stat_smooth()`).</code></pre>
<pre><code>## Warning: Removed 160 rows containing missing values or values outside the scale range
## (`geom_point()`).</code></pre>
<p><img src="week6_files/figure-html/scatter_plot_3-1.png" width="672" /></p>
<p>Here, just for demonstration purposes, we set the upper limit to be
less than the largest values of ESR1 expression and ggplot2 warned us
that some rows have been removed from the plot.</p>
<p>Another way to alter the way the plot looks is to define a
<strong><code>theme()</code></strong>. The theme controls the way in
which non-data components are displayed. You can specifiy your own
themes, e.g. to remove the grid lines you would do:</p>
<pre class="r"><code>ggplot(data = metabric,
       mapping = aes(x = GATA3, y = ESR1, colour = ER_status)) +
    geom_point(size = 0.6, alpha = 0.5) +
    theme(panel.grid = element_blank())</code></pre>
<p><img src="week6_files/figure-html/scatter_plot_7a-1.png" width="672" /></p>
<p>We wont cover themes in any more detail in this course, but you can
use them to control pretty much any aspect of the plot. On the other
hand, there are also a number of predefined themes (and more available
in packages such as <em>ggtheme</em>). For example the “minimal”
theme:</p>
<pre class="r"><code>ggplot(data = metabric,
       mapping = aes(x = GATA3, y = ESR1, colour = ER_status)) +
    geom_point(size = 0.6, alpha = 0.5) +
    theme_minimal()</code></pre>
<p><img src="week6_files/figure-html/scatter_plot_7-1.png" width="672" /></p>
</div>
<div id="colours" class="section level2">
<h2>Colours</h2>
<p>The colour asthetic is used with a categorical variable,
<code>ER_status</code>, in the scatter plots we’ve been customizing. The
default colour scale used by ggplot2 for categorical variables is
<code>scale_colour_discrete</code>. We can manually set the colours we
wish to use using <code>scale_colour_manual</code> instead.</p>
<pre class="r"><code>ggplot(data = metabric,
       mapping = aes(x = GATA3, y = ESR1, colour = ER_status)) +
    geom_point(size = 0.6, alpha = 0.5) +
    geom_smooth(method = &quot;lm&quot;) +
    scale_colour_manual(values = c(&quot;dodgerblue2&quot;, &quot;firebrick2&quot;))</code></pre>
<pre><code>## `geom_smooth()` using formula = &#39;y ~ x&#39;</code></pre>
<p><img src="week6_files/figure-html/scatter_plot_10-1.png" width="672" /></p>
<p>If we wanted to specifiy that “dodgerblue2” should be the colour for
“Positive” and “firebrick2” for negative, we need to add names to the
values vector:</p>
<pre class="r"><code>ggplot(data = metabric,
       mapping = aes(x = GATA3, y = ESR1, colour = ER_status)) +
    geom_point(size = 0.6, alpha = 0.5) +
    geom_smooth(method = &quot;lm&quot;) +
    scale_colour_manual(values = c(Positive = &quot;dodgerblue2&quot;,
                                   Negative = &quot;firebrick2&quot;))</code></pre>
<pre><code>## `geom_smooth()` using formula = &#39;y ~ x&#39;</code></pre>
<p><img src="week6_files/figure-html/scatter_plot_10a-1.png" width="672" /></p>
<p>Setting colours manually is ok when we only have two or three
categories but when we have a larger number it would be handy to be able
to choose from a selection of carefully-constructed colour palettes.
Helpfully, ggplot2 provides access to the <a
href="http://colorbrewer2.org">ColorBrewer</a> palettes through the
functions <code>scale_colour_brewer()</code> and
<code>scale_fill_brewer()</code>.</p>
<pre class="r"><code>ggplot(data = metabric,
       mapping = aes(x = GATA3, y = ESR1, colour = `3-gene_classifier`)) +
    geom_point(size = 0.6, alpha = 0.5, na.rm = TRUE) +
    scale_colour_brewer(palette = &quot;Set1&quot;)</code></pre>
<p><img src="week6_files/figure-html/scatter_plot_11-1.png" width="672" /></p>
<p>Look at the help page for <code>scale_colour_brewer</code> to see
what other colour palettes are available and visit the <a
href="http://colorbrewer2.org">ColorBrewer</a> website to see what these
look like.</p>
<p>We can also set other attributes of the scale at the same time. For
example, we could change the names (labels) of the categories.</p>
<pre class="r"><code>ggplot(data = metabric,
       mapping = aes(x = GATA3, y = ESR1, colour = ER_status)) +
    geom_point(size = 0.6, alpha = 0.5) +
    geom_smooth(method = &quot;lm&quot;) +
    scale_colour_manual(values = c(Positive = &quot;dodgerblue2&quot;,
                                   Negative = &quot;firebrick2&quot;),
                        labels = c(&quot;ER-negative&quot;, &quot;ER-positive&quot;))</code></pre>
<pre><code>## `geom_smooth()` using formula = &#39;y ~ x&#39;</code></pre>
<p><img src="week6_files/figure-html/scatter_plot_12-1.png" width="672" /></p>
<p>We have applied our own set of mappings from levels in the data to
aesthetic values.</p>
<p>For continuous variables we may wish to be able to change the colours
used in the colour gradient. To demonstrate we’ll use the Nottingham
prognostic index (NPI) values to colour points in the scatter plot of
ESR1 vs GATA3 expression on a continuous scale.</p>
<pre class="r"><code>ggplot(data = metabric,
       mapping = aes(x = GATA3,
                     y = ESR1,
                     colour = Nottingham_prognostic_index)) +
    geom_point(size = 0.6, alpha = 0.5)</code></pre>
<p><img src="week6_files/figure-html/scatter_plot_123-1.png" width="672" /></p>
<p>ggplot2 by default uses this black to blue continuours scale. Higher
NPI scores correspond to worse prognosis and lower chance of 5 year
survival. We’ll emphasize those points on the scatter plot by adjusting
our colour scale to run from white to red.</p>
<pre class="r"><code>metabric %&gt;%
    ggplot(mapping = aes(x = GATA3,
                         y = ESR1,
                         colour = Nottingham_prognostic_index)) +
    geom_point(size = 0.75) +
    scale_colour_gradient(low = &quot;white&quot;, high = &quot;red&quot;)</code></pre>
<p><img src="week6_files/figure-html/scatter_plot_14-1.png" width="672" /></p>
<p>In some cases it might make sense to specify two colour gradients
either side of a mid-point.</p>
<pre class="r"><code>metabric %&gt;%
    ggplot(mapping = aes(x = GATA3,
                         y = ESR1,
                         colour = Nottingham_prognostic_index)) +
    geom_point(size = 0.75) +
    scale_colour_gradient2(low = &quot;dodgerblue1&quot;,
                           mid = &quot;grey90&quot;,
                           high = &quot;firebrick1&quot;,
                           midpoint = 4.5)</code></pre>
<p><img src="week6_files/figure-html/scatter_plot_15-1.png" width="672" /></p>
</div>
</div>
<div id="summary" class="section level1">
<h1>Summary</h1>
<p>In this session we have covered the following:</p>
<ul>
<li>Computing summary values for groups of observations</li>
<li>Counting the numbers of observations within categories</li>
<li>Combining data from two tables through join operations</li>
<li>Customizing plots created with ggplot2 by changing labels, scales
and colours</li>
</ul>
</div>
<div id="exercises" class="section level1">
<h1>Exercises</h1>
<div class="exercise">
<ol style="list-style-type: decimal">
<li>Compute the average survival time for the ER-negative and
ER-positive groups. Note that such a comparison only makes sense for
those patients that are deceased so apply the appropriate filter first.
Add a column for the number of patients in each group. You can use
“metabric_clinical_data.csv” file.</li>
</ol>
<details>
<summary>
Answer
</summary>
<pre class="r"><code>library(tidyverse)
metabric &lt;- read_csv(&quot;data/metabric_clinical_data.csv&quot;)
metabric %&gt;%
   filter(Survival_status == &quot;DECEASED&quot;) %&gt;%
   group_by(ER_status) %&gt;%
   summarize(`Average survival time` = mean(Survival_time), N = n())</code></pre>
<pre><code>## # A tibble: 2 × 3
##   ER_status `Average survival time`     N
##   &lt;chr&gt;                       &lt;dbl&gt; &lt;int&gt;
## 1 Negative                     66.3   262
## 2 Positive                    111.    882</code></pre>
</details>
</div>
<div class="exercise">
<ol start="2" style="list-style-type: decimal">
<li>Compute the average tumour size, number of positive lymph nodes and
Nottingham prognostic index within ER-negative and ER-positive
patients.</li>
</ol>
<details>
<summary>
Answer
</summary>
<pre class="r"><code>library(tidyverse)
metabric &lt;- read_csv(&quot;data/metabric_clinical_data.csv&quot;)
metabric %&gt;%
    group_by(ER_status) %&gt;%
    summarize(across(c(Tumour_size,
                       Lymph_nodes_examined_positive,
                       Nottingham_prognostic_index),
                     mean, na.rm = TRUE))</code></pre>
<pre><code>## # A tibble: 3 × 4
##   ER_status Tumour_size Lymph_nodes_examined_positive Nottingham_prognostic_in…¹
##   &lt;chr&gt;           &lt;dbl&gt;                         &lt;dbl&gt;                      &lt;dbl&gt;
## 1 Negative         28.3                          2.62                       4.60
## 2 Positive         25.4                          1.73                       3.86
## 3 &lt;NA&gt;             35                            1.70                       2.26
## # ℹ abbreviated name: ¹​Nottingham_prognostic_index</code></pre>
</details>
</div>
<div class="exercise">
<ol start="3" style="list-style-type: decimal">
<li>Count the numbers of mutations for each gene and display the top 10
most frequently mutated genes using metabric_mutations.csv data.</li>
</ol>
<details>
<summary>
Answer
</summary>
<pre class="r"><code>mutations &lt;- read_csv(&quot;data/metabric_mutations.csv&quot;)
mutations %&gt;%
    count(Gene) %&gt;%
    arrange(desc(n)) %&gt;%
    head(10)</code></pre>
<pre><code>## # A tibble: 10 × 2
##    Gene       n
##    &lt;chr&gt;  &lt;int&gt;
##  1 PIK3CA  1122
##  2 TP53     897
##  3 AHNAK2   859
##  4 MUC16    666
##  5 SYNE1    468
##  6 KMT2C    389
##  7 MAP3K1   372
##  8 AHNAK    327
##  9 GATA3    301
## 10 DNAH11   300</code></pre>
</details>
</div>
<div class="exercise">
<ol start="4" style="list-style-type: decimal">
<li>In breast cancers, PIK3CA and TP53 are the most commonly mutated
genes with mutations occurring in specific regions of the gene. Find out
which codons of PIK3CA are most commonly mutated.</li>
</ol>
<details>
<summary>
Answer
</summary>
<pre class="r"><code>mutations %&gt;%
  filter(Gene == &quot;PIK3CA&quot;) %&gt;%
  count(Codon) %&gt;%
  arrange(desc(n))</code></pre>
<pre><code>## # A tibble: 88 × 2
##    Codon     n
##    &lt;dbl&gt; &lt;int&gt;
##  1  1047   471
##  2   545   192
##  3   542   101
##  4   345    64
##  5   726    28
##  6   546    26
##  7   420    19
##  8   111    13
##  9  1043    12
## 10   108    10
## # ℹ 78 more rows</code></pre>
</details>
</div>
<div class="exercise">
<ol start="5" style="list-style-type: decimal">
<li>Use boxplots to illustrate the distribution of diagnosis age for
3-gene classification groups of patients. Remove any patients who are
unclassified. The boxplots should be colored according to the
group.</li>
</ol>
<details>
<summary>
Answer
</summary>
<pre class="r"><code>metabric %&gt;%
  filter(!is.na(`3-gene_classifier`)) %&gt;%
ggplot( mapping=aes(x=`3-gene_classifier`, y=Age_at_diagnosis, colour=`3-gene_classifier`)) +
  geom_boxplot() +
  scale_colour_discrete(name=&quot;3 gene classifier&quot;)</code></pre>
<img src="week6_files/figure-html/unnamed-chunk-45-1.png" width="672" />
</details>
</div>
</div>



</div>
</div>

</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.odd').parent('tbody').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- tabsets -->

<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});

$(document).ready(function () {
  $('.tabset-dropdown > .nav-tabs > li').click(function () {
    $(this).parent().toggleClass('nav-tabs-open');
  });
});
</script>

<!-- code folding -->

<script>
$(document).ready(function ()  {

    // temporarily add toc-ignore selector to headers for the consistency with Pandoc
    $('.unlisted.unnumbered').addClass('toc-ignore')

    // move toc-ignore selectors from section div to header
    $('div.section.toc-ignore')
        .removeClass('toc-ignore')
        .children('h1,h2,h3,h4,h5').addClass('toc-ignore');

    // establish options
    var options = {
      selectors: "h1,h2,h3",
      theme: "bootstrap3",
      context: '.toc-content',
      hashGenerator: function (text) {
        return text.replace(/[.\\/?&!#<>]/g, '').replace(/\s/g, '_');
      },
      ignoreSelector: ".toc-ignore",
      scrollTo: 0
    };
    options.showAndHide = true;
    options.smoothScroll = true;

    // tocify
    var toc = $("#TOC").tocify(options).data("toc-tocify");
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
