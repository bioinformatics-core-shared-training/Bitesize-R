<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />




<title>Week 6 – Grouping and combining data</title>

<script src="site_libs/header-attrs-2.21/header-attrs.js"></script>
<script src="site_libs/jquery-3.6.0/jquery-3.6.0.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="site_libs/bootstrap-3.3.5/css/bootstrap.min.css" rel="stylesheet" />
<script src="site_libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/respond.min.js"></script>
<style>h1 {font-size: 34px;}
       h1.title {font-size: 38px;}
       h2 {font-size: 30px;}
       h3 {font-size: 24px;}
       h4 {font-size: 18px;}
       h5 {font-size: 16px;}
       h6 {font-size: 12px;}
       code {color: inherit; background-color: rgba(0, 0, 0, 0.04);}
       pre:not([class]) { background-color: white }</style>
<script src="site_libs/jqueryui-1.11.4/jquery-ui.min.js"></script>
<link href="site_libs/tocify-1.9.1/jquery.tocify.css" rel="stylesheet" />
<script src="site_libs/tocify-1.9.1/jquery.tocify.js"></script>
<script src="site_libs/navigation-1.1/tabsets.js"></script>
<link href="site_libs/highlightjs-9.12.0/default.css" rel="stylesheet" />
<script src="site_libs/highlightjs-9.12.0/highlight.js"></script>
<link href="site_libs/font-awesome-6.4.0/css/all.min.css" rel="stylesheet" />
<link href="site_libs/font-awesome-6.4.0/css/v4-shims.min.css" rel="stylesheet" />

<style type="text/css">
  code{white-space: pre-wrap;}
  span.smallcaps{font-variant: small-caps;}
  span.underline{text-decoration: underline;}
  div.column{display: inline-block; vertical-align: top; width: 50%;}
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  ul.task-list{list-style: none;}
    </style>

<style type="text/css">code{white-space: pre;}</style>
<script type="text/javascript">
if (window.hljs) {
  hljs.configure({languages: []});
  hljs.initHighlightingOnLoad();
  if (document.readyState && document.readyState === "complete") {
    window.setTimeout(function() { hljs.initHighlighting(); }, 0);
  }
}
</script>






<link rel="stylesheet" href="styles.css" type="text/css" />



<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
img {
  max-width:100%;
}
.tabbed-pane {
  padding-top: 12px;
}
.html-widget {
  margin-bottom: 20px;
}
button.code-folding-btn:focus {
  outline: none;
}
summary {
  display: list-item;
}
details > summary > p:only-child {
  display: inline;
}
pre code {
  padding: 0;
}
</style>


<style type="text/css">
.dropdown-submenu {
  position: relative;
}
.dropdown-submenu>.dropdown-menu {
  top: 0;
  left: 100%;
  margin-top: -6px;
  margin-left: -1px;
  border-radius: 0 6px 6px 6px;
}
.dropdown-submenu:hover>.dropdown-menu {
  display: block;
}
.dropdown-submenu>a:after {
  display: block;
  content: " ";
  float: right;
  width: 0;
  height: 0;
  border-color: transparent;
  border-style: solid;
  border-width: 5px 0 5px 5px;
  border-left-color: #cccccc;
  margin-top: 5px;
  margin-right: -10px;
}
.dropdown-submenu:hover>a:after {
  border-left-color: #adb5bd;
}
.dropdown-submenu.pull-left {
  float: none;
}
.dropdown-submenu.pull-left>.dropdown-menu {
  left: -100%;
  margin-left: 10px;
  border-radius: 6px 0 6px 6px;
}
</style>

<script type="text/javascript">
// manage active state of menu based on current page
$(document).ready(function () {
  // active menu anchor
  href = window.location.pathname
  href = href.substr(href.lastIndexOf('/') + 1)
  if (href === "")
    href = "index.html";
  var menuAnchor = $('a[href="' + href + '"]');

  // mark the anchor link active (and if it's in a dropdown, also mark that active)
  var dropdown = menuAnchor.closest('li.dropdown');
  if (window.bootstrap) { // Bootstrap 4+
    menuAnchor.addClass('active');
    dropdown.find('> .dropdown-toggle').addClass('active');
  } else { // Bootstrap 3
    menuAnchor.parent().addClass('active');
    dropdown.addClass('active');
  }

  // Navbar adjustments
  var navHeight = $(".navbar").first().height() + 15;
  var style = document.createElement('style');
  var pt = "padding-top: " + navHeight + "px; ";
  var mt = "margin-top: -" + navHeight + "px; ";
  var css = "";
  // offset scroll position for anchor links (for fixed navbar)
  for (var i = 1; i <= 6; i++) {
    css += ".section h" + i + "{ " + pt + mt + "}\n";
  }
  style.innerHTML = "body {" + pt + "padding-bottom: 40px; }\n" + css;
  document.head.appendChild(style);
});
</script>

<!-- tabsets -->

<style type="text/css">
.tabset-dropdown > .nav-tabs {
  display: inline-table;
  max-height: 500px;
  min-height: 44px;
  overflow-y: auto;
  border: 1px solid #ddd;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs > li.active:before, .tabset-dropdown > .nav-tabs.nav-tabs-open:before {
  content: "\e259";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li.active:before {
  content: "\e258";
  font-family: 'Glyphicons Halflings';
  border: none;
}

.tabset-dropdown > .nav-tabs > li.active {
  display: block;
}

.tabset-dropdown > .nav-tabs > li > a,
.tabset-dropdown > .nav-tabs > li > a:focus,
.tabset-dropdown > .nav-tabs > li > a:hover {
  border: none;
  display: inline-block;
  border-radius: 4px;
  background-color: transparent;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li {
  display: block;
  float: none;
}

.tabset-dropdown > .nav-tabs > li {
  display: none;
}
</style>

<!-- code folding -->



<style type="text/css">

#TOC {
  margin: 25px 0px 20px 0px;
}
@media (max-width: 768px) {
#TOC {
  position: relative;
  width: 100%;
}
}

@media print {
.toc-content {
  /* see https://github.com/w3c/csswg-drafts/issues/4434 */
  float: right;
}
}

.toc-content {
  padding-left: 30px;
  padding-right: 40px;
}

div.main-container {
  max-width: 1200px;
}

div.tocify {
  width: 20%;
  max-width: 260px;
  max-height: 85%;
}

@media (min-width: 768px) and (max-width: 991px) {
  div.tocify {
    width: 25%;
  }
}

@media (max-width: 767px) {
  div.tocify {
    width: 100%;
    max-width: none;
  }
}

.tocify ul, .tocify li {
  line-height: 20px;
}

.tocify-subheader .tocify-item {
  font-size: 0.90em;
}

.tocify .list-group-item {
  border-radius: 0px;
}


</style>



</head>

<body>


<div class="container-fluid main-container">


<!-- setup 3col/9col grid for toc_float and main content  -->
<div class="row">
<div class="col-xs-12 col-sm-4 col-md-3">
<div id="TOC" class="tocify">
</div>
</div>

<div class="toc-content col-xs-12 col-sm-8 col-md-9">




<div class="navbar navbar-default  navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-bs-toggle="collapse" data-target="#navbar" data-bs-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="index.html"><img style="width: 120px; float: left; margin-top: 0px; margin-right: 20px;" src="images/CRUK_CI_logo.png"/>R for Biologists&nbsp;&nbsp;&nbsp;</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">
    Contents
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="week1.html">Week 1 - An introduction to RStudio, R objects, data types, functions and vectors</a>
    </li>
    <li>
      <a href="week2.html">Week 2 - An introduction to other data structures</a>
    </li>
    <li>
      <a href="week3.html">Week 3 - Working with data in R</a>
    </li>
    <li>
      <a href="week4.html">Week 4 - Data visualization with ggplot2</a>
    </li>
    <li>
      <a href="week5.html">Week 5 - Data manipulation using dplyr</a>
    </li>
  </ul>
</li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        <li>
  <a href="https://github.com/bioinformatics-core-shared-training/Bitesize-R">
    <span class="fa fa-github fa-lg"></span>
     
  </a>
</li>
      </ul>
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

<div id="header">



<h1 class="title toc-ignore">Week 6 – Grouping and combining data</h1>

</div>


<blockquote>
<h4 id="learning-objectives">Learning objectives</h4>
<ul>
<li>Use <code>group_by()</code> with <code>summarise()</code> to compute
summary values for groups of observations</li>
<li>Use <code>count()</code> to count the numbers of observations within
categories</li>
<li>Combine data from two tables based on a common identifier
(<code>join</code> operations)</li>
<li>Customize plots created using ggplot2 by changing labels, scales and
colours</li>
</ul>
</blockquote>
<div id="grouping-and-combining-data" class="section level1">
<h1>Grouping and combining data</h1>
<p>In this session, we’ll look at some more useful functions provided by
the <strong>dplyr</strong> package, the ‘workhorse’ in the tidyverse
family for manipulating tabular data. Continuing from last week, we’ll
see how we can summarise data for groups of observations within
different categories. We’ll also show how dplyr allows us to combine
data for the same observational unit, e.g. person or date, that comes
from different sources and is read into R in different tables.</p>
<p>We’ll also look at how to customize the plots we create using
<strong>ggplot2</strong>, in particular how we can add or change titles
and labels, how we can adjust the way the axes are displayed and how we
can use a colour scheme of our choosing.</p>
<p><strong>dplyr</strong> and <strong>ggplot2</strong> are core
component packages within the tidyverse and both get loaded as part of
the tidyverse.</p>
<pre class="r"><code>library(tidyverse)</code></pre>
<pre><code>## ── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──
## ✔ dplyr     1.1.2     ✔ readr     2.1.4
## ✔ forcats   1.0.0     ✔ stringr   1.5.0
## ✔ ggplot2   3.4.2     ✔ tibble    3.2.1
## ✔ lubridate 1.9.2     ✔ tidyr     1.3.0
## ✔ purrr     1.0.1     
## ── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──
## ✖ dplyr::filter() masks stats::filter()
## ✖ dplyr::lag()    masks stats::lag()
## ℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors</code></pre>
<p>To demonstrate how these grouping and combining functions work and to
illustrate customization of plots, we’ll again use the METABRIC data
set.</p>
<pre class="r"><code>metabric &lt;- read_csv(&quot;data/metabric_clinical_and_expression_data.csv&quot;)
metabric</code></pre>
<pre><code>## # A tibble: 1,904 × 32
##    Patient_ID Cohort Age_at_diagnosis Survival_time Survival_status Vital_status
##    &lt;chr&gt;       &lt;dbl&gt;            &lt;dbl&gt;         &lt;dbl&gt; &lt;chr&gt;           &lt;chr&gt;       
##  1 MB-0000         1             75.6         140.  LIVING          Living      
##  2 MB-0002         1             43.2          84.6 LIVING          Living      
##  3 MB-0005         1             48.9         164.  DECEASED        Died of Dis…
##  4 MB-0006         1             47.7         165.  LIVING          Living      
##  5 MB-0008         1             77.0          41.4 DECEASED        Died of Dis…
##  6 MB-0010         1             78.8           7.8 DECEASED        Died of Dis…
##  7 MB-0014         1             56.4         164.  LIVING          Living      
##  8 MB-0022         1             89.1          99.5 DECEASED        Died of Oth…
##  9 MB-0028         1             86.4          36.6 DECEASED        Died of Oth…
## 10 MB-0035         1             84.2          36.3 DECEASED        Died of Dis…
## # ℹ 1,894 more rows
## # ℹ 26 more variables: Chemotherapy &lt;chr&gt;, Radiotherapy &lt;chr&gt;,
## #   Tumour_size &lt;dbl&gt;, Tumour_stage &lt;dbl&gt;, Neoplasm_histologic_grade &lt;dbl&gt;,
## #   Lymph_nodes_examined_positive &lt;dbl&gt;, Lymph_node_status &lt;dbl&gt;,
## #   Cancer_type &lt;chr&gt;, ER_status &lt;chr&gt;, PR_status &lt;chr&gt;, HER2_status &lt;chr&gt;,
## #   HER2_status_measured_by_SNP6 &lt;chr&gt;, PAM50 &lt;chr&gt;, `3-gene_classifier` &lt;chr&gt;,
## #   Nottingham_prognostic_index &lt;dbl&gt;, Cellularity &lt;chr&gt;, …</code></pre>
</div>
<div id="grouping-observations" class="section level1">
<h1>Grouping observations</h1>
<div id="summaries-for-groups" class="section level2">
<h2>Summaries for groups</h2>
<p>In the previous session we introduced the <code>summarise()</code>
function for computing a summary value for one or more variables from
all rows in a table (data frame or tibble). For example, we computed the
mean expression of ESR1, the estrogen receptor alpha gene, as
follows.</p>
<pre class="r"><code>summarise(metabric, mean(ESR1))</code></pre>
<pre><code>## # A tibble: 1 × 1
##   `mean(ESR1)`
##          &lt;dbl&gt;
## 1         9.61</code></pre>
<p>While the <code>summarise()</code> function is useful on its own, it
becomes really powerful when applied to groups of observations within a
dataset. For example, we might be more interested in the mean ESR1
expression calculated separately for ER positive and ER negative
tumours. We could take each group in turn, filter the data frame to
contain only the rows for a given ER status, then apply the
<code>summarise()</code> function to compute the mean expression, but
that would be somewhat cumbersome. Even more so if we chose to do this
for a categorical variable with more than two states, e.g. for each of
the integrative clusters. Fortunately, the
<strong><code>group_by()</code></strong> function allows this to be done
in one simple step.</p>
<pre class="r"><code>metabric %&gt;%
  group_by(ER_status) %&gt;%
  summarise(mean(ESR1))</code></pre>
<pre><code>## # A tibble: 2 × 2
##   ER_status `mean(ESR1)`
##   &lt;chr&gt;            &lt;dbl&gt;
## 1 Negative          6.21
## 2 Positive         10.6</code></pre>
<p>We get an additional column in our output for the categorical
variable, <code>ER_status</code>, and a row for each category.</p>
<p>Incidentally, we should expect this result of ER-positive tumours
having a higher expression of ESR1 on average than ER-negative tumours.
Simple summaries like this are a good way of checking that what we think
we know actually holds true in the data we’re looking at. Note that the
expression values are on a log<sub>2</sub>scale so ER-positive breast
cancers express ESR1 at a level that is approximately 20 times greater,
on average, than that of ER-negative tumours.</p>
<pre class="r"><code>2 ** (10.6 - 6.21)  # equivalent to (2 ** 10.6) / (2 ** 6.21)</code></pre>
<pre><code>## [1] 20.96629</code></pre>
<p>Let’s have a look at how ESR1 expression varies between the
integrative cluster subtypes defined by the METABRIC study.</p>
<pre class="r"><code>metabric %&gt;%
  group_by(Integrative_cluster) %&gt;%
  summarise(ESR1 = mean(ESR1))</code></pre>
<pre><code>## # A tibble: 11 × 2
##    Integrative_cluster  ESR1
##    &lt;chr&gt;               &lt;dbl&gt;
##  1 1                   10.3 
##  2 10                   6.39
##  3 2                   10.9 
##  4 3                   10.5 
##  5 4ER+                 9.78
##  6 4ER-                 6.55
##  7 5                    7.78
##  8 6                   10.9 
##  9 7                   10.9 
## 10 8                   11.1 
## 11 9                    9.96</code></pre>
<p>The following schematic contains another example using a simplified
subset of the METABRIC tumour samples to show what’s going on.</p>
<p><img src="images/group_and_summarise.png" /></p>
<p>As we saw last week, we can summarize multiple observations, e.g. the
mean expression for other genes of interest, with
<code>summarise_at()</code>, this time using the PAM50 classification to
define the groups.</p>
<pre class="r"><code>metabric %&gt;%
  group_by(PAM50) %&gt;%
  summarise_at(vars(ESR1, PGR, ERBB2), mean)</code></pre>
<pre><code>## # A tibble: 7 × 4
##   PAM50        ESR1   PGR ERBB2
##   &lt;chr&gt;       &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;
## 1 Basal        6.42  5.46 10.2 
## 2 Her2         7.81  5.62 12.6 
## 3 LumA        10.8   6.75 10.7 
## 4 LumB        11.0   6.39 10.6 
## 5 NC          10.9   6.47 10.3 
## 6 Normal       9.50  6.21 10.8 
## 7 claudin-low  7.47  5.60  9.85</code></pre>
<p>We can also refine our groups by using more than one categorical
variable. Let’s subdivide the PAM50 groups by HER2 status to illustrate
this.</p>
<pre class="r"><code>metabric %&gt;%
  group_by(PAM50, HER2_status) %&gt;%
  summarise(ESR1_mean = mean(ESR1))</code></pre>
<pre><code>## `summarise()` has grouped output by &#39;PAM50&#39;. You can override using the
## `.groups` argument.</code></pre>
<pre><code>## # A tibble: 13 × 3
## # Groups:   PAM50 [7]
##    PAM50       HER2_status ESR1_mean
##    &lt;chr&gt;       &lt;chr&gt;           &lt;dbl&gt;
##  1 Basal       Negative         6.39
##  2 Basal       Positive         6.71
##  3 Her2        Negative         8.82
##  4 Her2        Positive         7.04
##  5 LumA        Negative        10.8 
##  6 LumA        Positive        10.1 
##  7 LumB        Negative        11.1 
##  8 LumB        Positive        10.2 
##  9 NC          Negative        10.9 
## 10 Normal      Negative         9.68
## 11 Normal      Positive         7.77
## 12 claudin-low Negative         7.52
## 13 claudin-low Positive         6.80</code></pre>
<p>It can be quite useful to know how many observations are within each
group. We can use a special function, <strong><code>n()</code></strong>,
that counts the number of rows rather than computing a summary value
from one of the columns.</p>
<pre class="r"><code>metabric %&gt;%
  group_by(PAM50, HER2_status) %&gt;%
  summarise(N = n(), ESR1_mean = mean(ESR1))</code></pre>
<pre><code>## `summarise()` has grouped output by &#39;PAM50&#39;. You can override using the
## `.groups` argument.</code></pre>
<pre><code>## # A tibble: 13 × 4
## # Groups:   PAM50 [7]
##    PAM50       HER2_status     N ESR1_mean
##    &lt;chr&gt;       &lt;chr&gt;       &lt;int&gt;     &lt;dbl&gt;
##  1 Basal       Negative      179      6.39
##  2 Basal       Positive       20      6.71
##  3 Her2        Negative       95      8.82
##  4 Her2        Positive      125      7.04
##  5 LumA        Negative      658     10.8 
##  6 LumA        Positive       21     10.1 
##  7 LumB        Negative      419     11.1 
##  8 LumB        Positive       42     10.2 
##  9 NC          Negative        6     10.9 
## 10 Normal      Negative      127      9.68
## 11 Normal      Positive       13      7.77
## 12 claudin-low Negative      184      7.52
## 13 claudin-low Positive       15      6.80</code></pre>
</div>
<div id="counts" class="section level2">
<h2>Counts</h2>
<p>Counting observations within groups is such a common operation that
dplyr provides a <strong><code>count()</code></strong> function to do
just that. So we could count the number of patient samples in each of
the PAM50 classes as follows.</p>
<pre class="r"><code>count(metabric, PAM50)</code></pre>
<pre><code>## # A tibble: 7 × 2
##   PAM50           n
##   &lt;chr&gt;       &lt;int&gt;
## 1 Basal         199
## 2 Her2          220
## 3 LumA          679
## 4 LumB          461
## 5 NC              6
## 6 Normal        140
## 7 claudin-low   199</code></pre>
<p>This is much like the <code>table()</code> function we’ve used
several times already to take a quick look at what values are contained
in one of the columns in a data frame. They return different data
structures however, with <code>count()</code> always returning a data
frame (or tibble) that can then be passed to subsequent steps in a
‘piped’ workflow.</p>
<p>If we wanted to subdivide our categories by HER2 status, we can add
this as an additional categorical variable just as we did with the
previous <code>group_by()</code> examples.</p>
<pre class="r"><code>count(metabric, PAM50, HER2_status)</code></pre>
<pre><code>## # A tibble: 13 × 3
##    PAM50       HER2_status     n
##    &lt;chr&gt;       &lt;chr&gt;       &lt;int&gt;
##  1 Basal       Negative      179
##  2 Basal       Positive       20
##  3 Her2        Negative       95
##  4 Her2        Positive      125
##  5 LumA        Negative      658
##  6 LumA        Positive       21
##  7 LumB        Negative      419
##  8 LumB        Positive       42
##  9 NC          Negative        6
## 10 Normal      Negative      127
## 11 Normal      Positive       13
## 12 claudin-low Negative      184
## 13 claudin-low Positive       15</code></pre>
<p>The count column is named ‘n’ by default but you can change this.</p>
<pre class="r"><code>count(metabric, PAM50, HER2_status, name = &quot;Samples&quot;)</code></pre>
<pre><code>## # A tibble: 13 × 3
##    PAM50       HER2_status Samples
##    &lt;chr&gt;       &lt;chr&gt;         &lt;int&gt;
##  1 Basal       Negative        179
##  2 Basal       Positive         20
##  3 Her2        Negative         95
##  4 Her2        Positive        125
##  5 LumA        Negative        658
##  6 LumA        Positive         21
##  7 LumB        Negative        419
##  8 LumB        Positive         42
##  9 NC          Negative          6
## 10 Normal      Negative        127
## 11 Normal      Positive         13
## 12 claudin-low Negative        184
## 13 claudin-low Positive         15</code></pre>
<p><code>count()</code> is equivalent to grouping observations with
<code>group_by()</code> and calling <code>summarize()</code> using the
special <code>n()</code> function to count the number of rows. So the
above statement could have been written in a more long-winded way as
follows.</p>
<pre class="r"><code>metabric %&gt;%
  group_by(PAM50, HER2_status) %&gt;%
  summarize(Samples = n())</code></pre>
<p>Summarizing with <code>n()</code> is useful when showing the number
of observations in a group alongside a summary value, as we did earlier
looking at the mean ESR1 expression within specified groups; it allows
you to see if you’re drawing conclusions from only a few data
points.</p>
</div>
<div id="missing-values" class="section level2">
<h2>Missing values</h2>
<p>Many summarization functions return <code>NA</code> if any of the
values are missing, i.e. the column contains <code>NA</code> values. As
an example, we’ll compute the average size of ER-negative and
ER-positive tumours.</p>
<pre class="r"><code>metabric %&gt;%
  group_by(ER_status) %&gt;%
  summarize(N = n(), `Average tumour size` = mean(Tumour_size))</code></pre>
<pre><code>## # A tibble: 2 × 3
##   ER_status     N `Average tumour size`
##   &lt;chr&gt;     &lt;int&gt;                 &lt;dbl&gt;
## 1 Negative    445                    NA
## 2 Positive   1459                    NA</code></pre>
<p>The <code>mean()</code> function, along with many similar
summarization functions, has an <code>na.rm</code> argument that can be
set to <code>TRUE</code> to exclude those missing values from the
calculation.</p>
<pre class="r"><code>metabric %&gt;%
  group_by(ER_status) %&gt;%
  summarize(N = n(), `Average tumour size` = mean(Tumour_size, na.rm = TRUE))</code></pre>
<pre><code>## # A tibble: 2 × 3
##   ER_status     N `Average tumour size`
##   &lt;chr&gt;     &lt;int&gt;                 &lt;dbl&gt;
## 1 Negative    445                  28.5
## 2 Positive   1459                  25.6</code></pre>
<p>An alternative would be to filter out the observations with missing
values but then the number of samples in each ER status group would take
on a different meaning, which may or may not be what we actually
want.</p>
<pre class="r"><code>metabric %&gt;%
  filter(!is.na(Tumour_size)) %&gt;%
  group_by(ER_status) %&gt;%
  summarize(N = n(), `Average tumour size` = mean(Tumour_size))</code></pre>
<pre><code>## # A tibble: 2 × 3
##   ER_status     N `Average tumour size`
##   &lt;chr&gt;     &lt;int&gt;                 &lt;dbl&gt;
## 1 Negative    438                  28.5
## 2 Positive   1446                  25.6</code></pre>
</div>
<div id="counts-and-proportions" class="section level2">
<h2>Counts and proportions</h2>
<p>The <code>sum()</code> and <code>mean()</code> summarization
functions are often used with logical values. It might seem surprising
to compute a summary for a logical variable but but this turns out to be
quite a useful thing to do, for counting the number of <code>TRUE</code>
values or obtaining the proportion of values that are
<code>TRUE</code>.</p>
<p>Following on from the previous example we could add a column to our
summary of average tumour size for ER-positive and ER-negative patients
that contains the number of missing values.</p>
<pre class="r"><code>metabric %&gt;%
  group_by(ER_status) %&gt;%
  summarize(N = n(), Missing = sum(is.na(Tumour_size)), `Average tumour size` = mean(Tumour_size, na.rm = TRUE))</code></pre>
<pre><code>## # A tibble: 2 × 4
##   ER_status     N Missing `Average tumour size`
##   &lt;chr&gt;     &lt;int&gt;   &lt;int&gt;                 &lt;dbl&gt;
## 1 Negative    445       7                  28.5
## 2 Positive   1459      13                  25.6</code></pre>
<p>Why does this work? Well, the <code>is.na()</code> function takes a
vector and sees which values are <code>NA</code>, returning a logical
vector of <code>TRUE</code> where the value was <code>NA</code> and
<code>FALSE</code> if not.</p>
<pre class="r"><code>test_vector &lt;- c(1, 3, 2, NA, 6, 5, NA, 10)
is.na(test_vector)</code></pre>
<pre><code>## [1] FALSE FALSE FALSE  TRUE FALSE FALSE  TRUE FALSE</code></pre>
<p>The <code>sum()</code> function treats the logical vector as a set of
<code>0</code>s and <code>1</code>s where <code>FALSE</code> is
<code>0</code> and <code>TRUE</code> is <code>1</code>. In effect
<code>sum()</code> counts the number of <code>TRUE</code> values.</p>
<pre class="r"><code>sum(is.na(test_vector))</code></pre>
<pre><code>## [1] 2</code></pre>
<p>Similarly, <code>mean()</code> will compute the proportion of the
values that are <code>TRUE</code>.</p>
<pre class="r"><code>mean(is.na(test_vector))</code></pre>
<pre><code>## [1] 0.25</code></pre>
<p>So let’s calculate the number and proportion of samples that do not
have a recorded tumour size in each of the ER-negative and ER-positive
groups.</p>
<pre class="r"><code>metabric %&gt;%
  group_by(ER_status) %&gt;%
  summarize(N = n(), `Missing tumour size` = sum(is.na(Tumour_size)), `Proportion missing` = mean(is.na(Tumour_size)))</code></pre>
<pre><code>## # A tibble: 2 × 4
##   ER_status     N `Missing tumour size` `Proportion missing`
##   &lt;chr&gt;     &lt;int&gt;                 &lt;int&gt;                &lt;dbl&gt;
## 1 Negative    445                     7              0.0157 
## 2 Positive   1459                    13              0.00891</code></pre>
<p>We can use <code>sum()</code> and <code>mean()</code> for any
condition that returns a logical vector. We could, for example, find the
number and proportion of patients that survived longer than 10 years
(120 months) in each of the ER-negative and ER-positive groups.</p>
<pre class="r"><code>metabric %&gt;%
  filter(Survival_status == &quot;DECEASED&quot;) %&gt;%
  group_by(ER_status) %&gt;%
  summarise(N = n(), N_long_survival = sum(Survival_time &gt; 120), Proportion_long_survival = mean(Survival_time &gt; 120))</code></pre>
<pre><code>## # A tibble: 2 × 4
##   ER_status     N N_long_survival Proportion_long_survival
##   &lt;chr&gt;     &lt;int&gt;           &lt;int&gt;                    &lt;dbl&gt;
## 1 Negative    250              40                    0.16 
## 2 Positive    853             325                    0.381</code></pre>
</div>
<div id="selecting-or-counting-distinct-things" class="section level2">
<h2>Selecting or counting distinct things</h2>
<p>There are occassions when we want to count the number of distinct
values in a variable or a combination of variables. In this week’s
assignment, we introduce another set of data from the METABRIC study
which contains details of the mutations detected by targeted sequencing
of a panel of 173 genes. We’ll read this data into R now as this
provides a good example of having multiple observations in different
rows for a single observational unit, in this case several mutations
detected in each tumour sample.</p>
<pre class="r"><code># download metabric mutation data
download.file(url=&quot;https://bioinformatics-core-shared-training.github.io/Bitesize-R/data/metabric_mutations.csv&quot;,destfile = &quot;data/metabric_mutations.csv&quot;)</code></pre>
<pre class="r"><code>mutations &lt;- read_csv(&quot;data/metabric_mutations.csv&quot;)
select(mutations, Patient_ID, Chromosome, Position = Start_Position, Ref = Reference_Allele, Alt = Tumor_Seq_Allele1, Type = Variant_Type, Gene)</code></pre>
<pre><code>## # A tibble: 17,272 × 7
##    Patient_ID Chromosome  Position Ref   Alt   Type  Gene 
##    &lt;chr&gt;      &lt;chr&gt;          &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;
##  1 MTS-T0058  17           7579344 &lt;NA&gt;  &lt;NA&gt;  INS   TP53 
##  2 MTS-T0058  17           7579346 &lt;NA&gt;  &lt;NA&gt;  INS   TP53 
##  3 MTS-T0058  6          168299111 G     G     SNP   MLLT4
##  4 MTS-T0058  22          29999995 G     G     SNP   NF2  
##  5 MTS-T0059  2          198288682 A     A     SNP   SF3B1
##  6 MTS-T0059  6           86195125 T     T     SNP   NT5E 
##  7 MTS-T0059  7           55241717 C     C     SNP   EGFR 
##  8 MTS-T0059  10           6556986 C     C     SNP   PRKCQ
##  9 MTS-T0059  11          62300529 T     T     SNP   AHNAK
## 10 MTS-T0059  15          74912475 G     G     SNP   CLK3 
## # ℹ 17,262 more rows</code></pre>
<p>We can see from just these few rows that each patient sample has
multiple mutations and sometimes there are more than one mutation in the
same gene within a sample, as can be seen in the first two rows at the
top of the table above.</p>
<p>If we want to count the number of patients in which mutations were
detected we could select the distinct set of patient identifiers using
the <strong><code>distinct()</code></strong> function.</p>
<pre class="r"><code>mutations %&gt;%
  distinct(Patient_ID) %&gt;%
  nrow()</code></pre>
<pre><code>## [1] 2369</code></pre>
<p>Similarly, we could select the distinct set of mutated genes for each
patient as follows.</p>
<pre class="r"><code>mutations %&gt;%
  distinct(Patient_ID, Gene)</code></pre>
<pre><code>## # A tibble: 15,656 × 2
##    Patient_ID Gene 
##    &lt;chr&gt;      &lt;chr&gt;
##  1 MTS-T0058  TP53 
##  2 MTS-T0058  MLLT4
##  3 MTS-T0058  NF2  
##  4 MTS-T0059  SF3B1
##  5 MTS-T0059  NT5E 
##  6 MTS-T0059  EGFR 
##  7 MTS-T0059  PRKCQ
##  8 MTS-T0059  AHNAK
##  9 MTS-T0059  CLK3 
## 10 MTS-T0059  TP53 
## # ℹ 15,646 more rows</code></pre>
<p>This has reduced the number of rows as only distinct combinations of
patient and gene are retained. This would be necessary if we wanted to
count the number of patients that have mutations in each gene rather
than the number of mutations for that gene regardless of the
patient.</p>
<pre class="r"><code># number of mutations for each gene
count(mutations, Gene)</code></pre>
<pre><code>## # A tibble: 173 × 2
##    Gene       n
##    &lt;chr&gt;  &lt;int&gt;
##  1 ACVRL1    20
##  2 AFF2      70
##  3 AGMO      43
##  4 AGTR2     14
##  5 AHNAK    327
##  6 AHNAK2   859
##  7 AKAP9    182
##  8 AKT1     115
##  9 AKT2      23
## 10 ALK       98
## # ℹ 163 more rows</code></pre>
<pre class="r"><code># number of tumour samples in which each gene is mutated
mutations %&gt;%
  distinct(Patient_ID, Gene) %&gt;%
  count(Gene)</code></pre>
<pre><code>## # A tibble: 173 × 2
##    Gene       n
##    &lt;chr&gt;  &lt;int&gt;
##  1 ACVRL1    20
##  2 AFF2      69
##  3 AGMO      43
##  4 AGTR2     14
##  5 AHNAK    272
##  6 AHNAK2   530
##  7 AKAP9    173
##  8 AKT1     115
##  9 AKT2      23
## 10 ALK       95
## # ℹ 163 more rows</code></pre>
<p>The genes that differ in these two tables are those that have more
than one mutation within a patient tumour sample.</p>
</div>
</div>
<div id="joining-data" class="section level1">
<h1>Joining data</h1>
<p>In many real life situations, data are spread across multiple tables
or spreadsheets. Usually this occurs because different types of
information about a subject, e.g. a patient, are collected from
different sources. It may be desirable for some analyses to combine data
from two or more tables into a single data frame based on a common
column, for example, an attribute that uniquely identifies the subject
such as a patient identifier.</p>
<p>dplyr provides a set of join functions for combining two data frames
based on matches within specified columns. These operations are very
similar to carrying out join operations between tables in a relational
database using SQL.</p>
<div id="left_join" class="section level2">
<h2><code>left_join</code></h2>
<p>To illustrate join operations we’ll first consider the most common
type, a “left join”. In the schematic below the two data frames share a
common column, V1. We can combine the two data frames into a single data
frame by matching rows in the first data frame with those in the second
data frame that share the same value of variable V1.</p>
<div class="figure">
<img src="images/dplyr_left_join.png" alt="" />
<p class="caption">dplyr left join</p>
</div>
<p><code>left_join()</code> returns all rows from the first data frame
regardless of whether there is a match in the second data frame. Rows
with no match are included in the resulting data frame but have
<code>NA</code> values in the additional columns coming from the second
data frame.</p>
<p>Here’s an example in which details about members of the Beatles and
Rolling Stones are contained in two tables, using data frames
conveniently provided by dplyr (we’ll look at a real example
shortly).</p>
<p>The name column identifies each of the band members and is used for
matching rows from the two tables.</p>
<pre class="r"><code>band_members</code></pre>
<pre><code>## # A tibble: 3 × 2
##   name  band   
##   &lt;chr&gt; &lt;chr&gt;  
## 1 Mick  Stones 
## 2 John  Beatles
## 3 Paul  Beatles</code></pre>
<pre class="r"><code>band_instruments</code></pre>
<pre><code>## # A tibble: 3 × 2
##   name  plays 
##   &lt;chr&gt; &lt;chr&gt; 
## 1 John  guitar
## 2 Paul  bass  
## 3 Keith guitar</code></pre>
<pre class="r"><code>left_join(band_members, band_instruments, by = &quot;name&quot;)</code></pre>
<pre><code>## # A tibble: 3 × 3
##   name  band    plays 
##   &lt;chr&gt; &lt;chr&gt;   &lt;chr&gt; 
## 1 Mick  Stones  &lt;NA&gt;  
## 2 John  Beatles guitar
## 3 Paul  Beatles bass</code></pre>
<p>We have joined the band members and instruments tables based on the
common <code>name</code> column. Because this is a left join, only
observations for band members in the ‘left’ table
(<code>band_members</code>) are included with information brought in
from the ‘right’ table (<code>band_instruments</code>) where such
exists. There is no entry in <code>band_instruments</code> for Mick so
an <code>NA</code> value is inserted into the <code>plays</code> column
that gets added in the combined data frame. Keith is only included in
the <code>band_instruments</code> data frame so doesn’t make it into the
final output as this is based on those band members in the ‘left’
table.</p>
<p><code>right_join()</code> is similar but returns all rows from the
second data frame, i.e. the ‘right’ data frame, that have a match with
rows in the first data frame.</p>
<pre class="r"><code>right_join(band_members, band_instruments, by = &quot;name&quot;)</code></pre>
<pre><code>## # A tibble: 3 × 3
##   name  band    plays 
##   &lt;chr&gt; &lt;chr&gt;   &lt;chr&gt; 
## 1 John  Beatles guitar
## 2 Paul  Beatles bass  
## 3 Keith &lt;NA&gt;    guitar</code></pre>
<p><code>right_join()</code> is used very infrequently compared with
<code>left_join()</code>.</p>
</div>
<div id="inner_join" class="section level2">
<h2><code>inner_join</code></h2>
<p>Another joining operation is the “inner join” in which only
observations that are common to both data frames are included.</p>
<div class="figure">
<img src="images/dplyr_inner_join.png" alt="" />
<p class="caption">dplyr inner join</p>
</div>
<pre class="r"><code>inner_join(band_members, band_instruments, by = &quot;name&quot;)</code></pre>
<pre><code>## # A tibble: 2 × 3
##   name  band    plays 
##   &lt;chr&gt; &lt;chr&gt;   &lt;chr&gt; 
## 1 John  Beatles guitar
## 2 Paul  Beatles bass</code></pre>
<p>In this case when considering observations identified by
<code>name</code>, only John and Paul are contained in both the
<code>band_members</code> and <code>band_instruments</code> tables, so
only these make it into the combined table.</p>
</div>
<div id="full_join" class="section level2">
<h2><code>full_join</code></h2>
<p>We’ve seen how missing rows from one table can be retained in the
joined data frame using <code>left_join</code> or
<code>right_join</code> but sometimes data for a given subject may be
missing from either of the tables and we still want that subject to
appear in the combined table. A <code>full_join</code> will return all
rows and all columns from the two tables and where there are no matching
values, <code>NA</code> values are used to fill in the missing
values.</p>
<div class="figure">
<img src="images/dplyr_full_join.png" alt="" />
<p class="caption">dplyr full join</p>
</div>
<pre class="r"><code>full_join(band_members, band_instruments, by = &quot;name&quot;)</code></pre>
<pre><code>## # A tibble: 4 × 3
##   name  band    plays 
##   &lt;chr&gt; &lt;chr&gt;   &lt;chr&gt; 
## 1 Mick  Stones  &lt;NA&gt;  
## 2 John  Beatles guitar
## 3 Paul  Beatles bass  
## 4 Keith &lt;NA&gt;    guitar</code></pre>
<p>Now, with <code>full_join()</code>, we have rows for both Mick and
Keith even though they are only in one or other of the tables being
joined.</p>
</div>
<div id="joining-on-columns-with-different-headers"
class="section level2">
<h2>Joining on columns with different headers</h2>
<p>It isn’t uncommon for the columns used for joining two tables to have
different names in each table. Of course we could rename one of the two
columns, e.g. using the dplyr <code>rename()</code> function, but the
dplyr join functions allow you to match using differently-named columns
as illustrated using another version of the
<code>band_instruments</code> data frame.</p>
<pre class="r"><code>band_instruments2</code></pre>
<pre><code>## # A tibble: 3 × 2
##   artist plays 
##   &lt;chr&gt;  &lt;chr&gt; 
## 1 John   guitar
## 2 Paul   bass  
## 3 Keith  guitar</code></pre>
<pre class="r"><code>left_join(band_members, band_instruments2, by = c(&quot;name&quot; = &quot;artist&quot;))</code></pre>
<pre><code>## # A tibble: 3 × 3
##   name  band    plays 
##   &lt;chr&gt; &lt;chr&gt;   &lt;chr&gt; 
## 1 Mick  Stones  &lt;NA&gt;  
## 2 John  Beatles guitar
## 3 Paul  Beatles bass</code></pre>
<p>The name for the column used for joining is the one given in the
first table, i.e. the ‘left’ table, so <code>name</code> rather than
<code>artist</code> in this case.</p>
</div>
<div id="multiple-matches-in-join-operations" class="section level2">
<h2>Multiple matches in join operations</h2>
<p>You may be wondering what happens if there are multiple rows in one
of both of the two tables for the thing that is being joined, for
example what would happen if our second table had two entries for
instruments that Paul plays.</p>
<pre class="r"><code>band_instruments3 &lt;- tibble(
  name =  c(&quot;John&quot;,   &quot;Paul&quot;, &quot;Paul&quot;,   &quot;Keith&quot;),
  plays = c(&quot;guitar&quot;, &quot;bass&quot;, &quot;guitar&quot;, &quot;guitar&quot;)
)
band_instruments3</code></pre>
<pre><code>## # A tibble: 4 × 2
##   name  plays 
##   &lt;chr&gt; &lt;chr&gt; 
## 1 John  guitar
## 2 Paul  bass  
## 3 Paul  guitar
## 4 Keith guitar</code></pre>
<pre class="r"><code>left_join(band_members, band_instruments3, by = &quot;name&quot;)</code></pre>
<pre><code>## # A tibble: 4 × 3
##   name  band    plays 
##   &lt;chr&gt; &lt;chr&gt;   &lt;chr&gt; 
## 1 Mick  Stones  &lt;NA&gt;  
## 2 John  Beatles guitar
## 3 Paul  Beatles bass  
## 4 Paul  Beatles guitar</code></pre>
<p>We get both entries from the second table added to the first
table.</p>
<p>Let’s add an entry for Paul being in a second band and see what
happens then when we combine the two tables, each with two entries for
Paul.</p>
<pre class="r"><code>band_members3 &lt;- tibble(
  name = c(&quot;Mick&quot;,   &quot;John&quot;,    &quot;Paul&quot;,    &quot;Paul&quot;),
  band = c(&quot;Stones&quot;, &quot;Beatles&quot;, &quot;Beatles&quot;, &quot;Wings&quot;)
)
band_members3</code></pre>
<pre><code>## # A tibble: 4 × 2
##   name  band   
##   &lt;chr&gt; &lt;chr&gt;  
## 1 Mick  Stones 
## 2 John  Beatles
## 3 Paul  Beatles
## 4 Paul  Wings</code></pre>
<pre class="r"><code>left_join(band_members3, band_instruments3, by = &quot;name&quot;)</code></pre>
<pre><code>## Warning in left_join(band_members3, band_instruments3, by = &quot;name&quot;): Detected an unexpected many-to-many relationship between `x` and `y`.
## ℹ Row 3 of `x` matches multiple rows in `y`.
## ℹ Row 2 of `y` matches multiple rows in `x`.
## ℹ If a many-to-many relationship is expected, set `relationship =
##   &quot;many-to-many&quot;` to silence this warning.</code></pre>
<pre><code>## # A tibble: 6 × 3
##   name  band    plays 
##   &lt;chr&gt; &lt;chr&gt;   &lt;chr&gt; 
## 1 Mick  Stones  &lt;NA&gt;  
## 2 John  Beatles guitar
## 3 Paul  Beatles bass  
## 4 Paul  Beatles guitar
## 5 Paul  Wings   bass  
## 6 Paul  Wings   guitar</code></pre>
<p>The resulting table includes all combinations of band and instrument
for Paul.</p>
</div>
<div id="joining-by-matching-on-multiple-columns"
class="section level2">
<h2>Joining by matching on multiple columns</h2>
<p>Sometimes the observations being combined are identified by multiple
columns, for example, a forename and a surname. We can specify a vector
of column names to be used in the join operation.</p>
<pre class="r"><code>band_members4 &lt;- tibble(
  forename = c(&quot;Mick&quot;,   &quot;John&quot;,    &quot;Paul&quot;,      &quot;Mick&quot;,  &quot;John&quot;),
  surname =  c(&quot;Jagger&quot;, &quot;Lennon&quot;,  &quot;McCartney&quot;, &quot;Avory&quot;, &quot;Squire&quot;),
  band =     c(&quot;Stones&quot;, &quot;Beatles&quot;, &quot;Beatles&quot;,   &quot;Kinks&quot;, &quot;Roses&quot;)
)
band_instruments4 &lt;- tibble(
  forename = c(&quot;John&quot;,   &quot;Paul&quot;,      &quot;Keith&quot;,    &quot;Mick&quot;,  &quot;John&quot;),
  surname =  c(&quot;Lennon&quot;, &quot;McCartney&quot;, &quot;Richards&quot;, &quot;Avory&quot;, &quot;Squire&quot;),
  plays =    c(&quot;guitar&quot;, &quot;bass&quot;,      &quot;guitar&quot;,   &quot;drums&quot;, &quot;guitar&quot;)
)
full_join(band_members4, band_instruments4, by = c(&quot;forename&quot;, &quot;surname&quot;))</code></pre>
<pre><code>## # A tibble: 6 × 4
##   forename surname   band    plays 
##   &lt;chr&gt;    &lt;chr&gt;     &lt;chr&gt;   &lt;chr&gt; 
## 1 Mick     Jagger    Stones  &lt;NA&gt;  
## 2 John     Lennon    Beatles guitar
## 3 Paul     McCartney Beatles bass  
## 4 Mick     Avory     Kinks   drums 
## 5 John     Squire    Roses   guitar
## 6 Keith    Richards  &lt;NA&gt;    guitar</code></pre>
</div>
<div id="clashing-column-names" class="section level2">
<h2>Clashing column names</h2>
<p>Occasionally we may find that there are duplicated columns in the two
tables we want to join, columns that aren’t those used for joining.
These variables may even contain different data but happen to have the
same name. In such cases dplyr joins add a suffix to each column in the
combined table.</p>
<pre class="r"><code>band_members5 &lt;- tibble(
  name = c(&quot;John&quot;, &quot;Paul&quot;, &quot;Ringo&quot;, &quot;George&quot;, &quot;Mick&quot;),
  birth_year = c(1940, 1942, 1940, 1943, 1943),
  band = c(&quot;Beatles&quot;, &quot;Beatles&quot;, &quot;Beatles&quot;, &quot;Beatles&quot;, &quot;Stones&quot;)
)
band_instruments5 &lt;- tibble(
  name = c(&quot;John&quot;, &quot;Paul&quot;, &quot;Ringo&quot;, &quot;George&quot;),
  birth_year = c(1940, 1942, 1940, 1943),
  instrument = c(&quot;guitar&quot;, &quot;bass&quot;, &quot;drums&quot;, &quot;guitar&quot;)
)
left_join(band_members5, band_instruments5, by = &quot;name&quot;)</code></pre>
<pre><code>## # A tibble: 5 × 5
##   name   birth_year.x band    birth_year.y instrument
##   &lt;chr&gt;         &lt;dbl&gt; &lt;chr&gt;          &lt;dbl&gt; &lt;chr&gt;     
## 1 John           1940 Beatles         1940 guitar    
## 2 Paul           1942 Beatles         1942 bass      
## 3 Ringo          1940 Beatles         1940 drums     
## 4 George         1943 Beatles         1943 guitar    
## 5 Mick           1943 Stones            NA &lt;NA&gt;</code></pre>
<p>It is advisable to rename or remove the duplicated columns that
aren’t used for joining.</p>
</div>
<div id="filtering-joins" class="section level2">
<h2>Filtering joins</h2>
<p>A variation on the join operations we’ve considered are
<code>semi_join()</code> and <code>anti_join()</code> that filter the
rows in one table based on matches or lack of matches to rows in another
table.</p>
<p><code>semi_join()</code> returns all rows from the first table where
there are matches in the other table.</p>
<pre class="r"><code>semi_join(band_members, band_instruments, by = &quot;name&quot;)</code></pre>
<pre><code>## # A tibble: 2 × 2
##   name  band   
##   &lt;chr&gt; &lt;chr&gt;  
## 1 John  Beatles
## 2 Paul  Beatles</code></pre>
<p><code>anti_join()</code> returns all rows where there is no match in
the other table, i.e. those that are unique to the first table.</p>
<pre class="r"><code>anti_join(band_members, band_instruments, by = &quot;name&quot;)</code></pre>
<pre><code>## # A tibble: 1 × 2
##   name  band  
##   &lt;chr&gt; &lt;chr&gt; 
## 1 Mick  Stones</code></pre>
</div>
<div
id="a-real-example-joining-the-metabric-clinical-and-mrna-expression-data"
class="section level2">
<h2>A real example: joining the METABRIC clinical and mRNA expression
data</h2>
<p>Let’s move on to a real example of joining data from two different
tables that we used in putting together the combined METABRIC clinical
and expression data set.</p>
<p>We first read the clinical data into R and then just select a small
number of columns to make it easier to see what is going on when
combining the data.</p>
<pre class="r"><code># download metabric clinical data
download.file(url=&quot;https://bioinformatics-core-shared-training.github.io/Bitesize-R/data/metabric_clinical_data.csv&quot;,destfile = &quot;data/metabric_clinical_data.csv&quot;)</code></pre>
<pre class="r"><code>clinical_data &lt;- read_csv(&quot;data/metabric_clinical_data.csv&quot;)
clinical_data &lt;- select(clinical_data, Patient_ID, ER_status, PAM50)
clinical_data</code></pre>
<pre><code>## # A tibble: 2,509 × 3
##    Patient_ID ER_status PAM50      
##    &lt;chr&gt;      &lt;chr&gt;     &lt;chr&gt;      
##  1 MB-0000    Positive  claudin-low
##  2 MB-0002    Positive  LumA       
##  3 MB-0005    Positive  LumB       
##  4 MB-0006    Positive  LumB       
##  5 MB-0008    Positive  LumB       
##  6 MB-0010    Positive  LumB       
##  7 MB-0014    Positive  LumB       
##  8 MB-0020    Negative  Normal     
##  9 MB-0022    Positive  claudin-low
## 10 MB-0025    Positive  &lt;NA&gt;       
## # ℹ 2,499 more rows</code></pre>
<p>We then read in the mRNA expression data that was downloaded
separately from <a
href="https://www.cbioportal.org/study/summary?id=brca_metabric">cBioPortal</a>.</p>
<pre class="r"><code>download.file(url=&quot;https://bioinformatics-core-shared-training.github.io/Bitesize-R/data/metabric_mrna_expression.txt&quot;,destfile = &quot;data/metabric_mrna_expression.txt&quot;)</code></pre>
<pre class="r"><code>mrna_expression_data &lt;- read_tsv(&quot;data/metabric_mrna_expression.txt&quot;)
mrna_expression_data</code></pre>
<pre><code>## # A tibble: 2,509 × 10
##    STUDY_ID      SAMPLE_ID  ESR1 ERBB2   PGR  TP53 PIK3CA GATA3 FOXA1  MLPH
##    &lt;chr&gt;         &lt;chr&gt;     &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;
##  1 brca_metabric MB-0000    8.93  9.33  5.68  6.34   5.70  6.93  7.95  9.73
##  2 brca_metabric MB-0002   10.0   9.73  7.51  6.19   5.76 11.3  11.8  12.5 
##  3 brca_metabric MB-0005   10.0   9.73  7.38  6.40   6.75  9.29 11.7  10.3 
##  4 brca_metabric MB-0006   10.4  10.3   6.82  6.87   7.22  8.67 11.9  10.5 
##  5 brca_metabric MB-0008   11.3   9.96  7.33  6.34   5.82  9.72 11.6  12.2 
##  6 brca_metabric MB-0010   11.2   9.74  5.95  5.42   6.12  9.79 12.1  11.4 
##  7 brca_metabric MB-0014   10.8   9.28  7.72  5.99   7.48  8.37 11.5  10.8 
##  8 brca_metabric MB-0020   NA    NA    NA    NA     NA    NA    NA    NA   
##  9 brca_metabric MB-0022   10.4   8.61  5.59  6.17   7.59  7.87 10.7   9.95
## 10 brca_metabric MB-0025   NA    NA    NA    NA     NA    NA    NA    NA   
## # ℹ 2,499 more rows</code></pre>
<p>Now we have both sets of data loaded into R as data frames, we can
combine them into a single data frame using an
<code>inner_join()</code>. Our resulting table will only contain entries
for the patients for which expression data are available.</p>
<pre class="r"><code>combined_data &lt;- inner_join(clinical_data, mrna_expression_data, by = c(&quot;Patient_ID&quot; = &quot;SAMPLE_ID&quot;))
combined_data</code></pre>
<pre><code>## # A tibble: 2,509 × 12
##    Patient_ID ER_status PAM50      STUDY_ID  ESR1 ERBB2   PGR  TP53 PIK3CA GATA3
##    &lt;chr&gt;      &lt;chr&gt;     &lt;chr&gt;      &lt;chr&gt;    &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt;
##  1 MB-0000    Positive  claudin-l… brca_me…  8.93  9.33  5.68  6.34   5.70  6.93
##  2 MB-0002    Positive  LumA       brca_me… 10.0   9.73  7.51  6.19   5.76 11.3 
##  3 MB-0005    Positive  LumB       brca_me… 10.0   9.73  7.38  6.40   6.75  9.29
##  4 MB-0006    Positive  LumB       brca_me… 10.4  10.3   6.82  6.87   7.22  8.67
##  5 MB-0008    Positive  LumB       brca_me… 11.3   9.96  7.33  6.34   5.82  9.72
##  6 MB-0010    Positive  LumB       brca_me… 11.2   9.74  5.95  5.42   6.12  9.79
##  7 MB-0014    Positive  LumB       brca_me… 10.8   9.28  7.72  5.99   7.48  8.37
##  8 MB-0020    Negative  Normal     brca_me… NA    NA    NA    NA     NA    NA   
##  9 MB-0022    Positive  claudin-l… brca_me… 10.4   8.61  5.59  6.17   7.59  7.87
## 10 MB-0025    Positive  &lt;NA&gt;       brca_me… NA    NA    NA    NA     NA    NA   
## # ℹ 2,499 more rows
## # ℹ 2 more variables: FOXA1 &lt;dbl&gt;, MLPH &lt;dbl&gt;</code></pre>
<p>Having combined the data, we can carry out exploratory data analysis
using elements from both data sets.</p>
<pre class="r"><code>combined_data %&gt;%
  filter(!is.na(PAM50), !is.na(ESR1)) %&gt;%
  ggplot(mapping = aes(x = PAM50, y = ESR1, colour = PAM50)) +
  geom_boxplot(show.legend = FALSE)</code></pre>
<p><img src="week6_files/figure-html/box_plot_1-1.png" width="672" /></p>
</div>
</div>
<div id="customizing-plots-with-ggplot2" class="section level1">
<h1>Customizing plots with ggplot2</h1>
<p>Finally, we’ll turn our attention back to visualization using ggplot2
and how we can customize our plots by adding or changing titles and
labels, changing the scales used on the x and y axes, and choosing
colours.</p>
<div id="titles-and-labels" class="section level2">
<h2>Titles and labels</h2>
<p>Adding titles and subtitles to a plot and changing the x- and y-axis
labels is very straightforward using the <code>labs()</code>
function.</p>
<pre class="r"><code>plot &lt;- ggplot(data = metabric, mapping = aes(x = GATA3, y = ESR1, colour = ER_status)) +
  geom_point(size = 0.6, alpha = 0.5) +
  geom_smooth(method = &quot;lm&quot;) +
  labs(
    title = &quot;mRNA expression in the METABRIC breast cancer data set&quot;,
    subtitle = &quot;GATA3 and ESR1 mRNA expression measured using Illumina HT-12 bead arrays&quot;,
    x = &quot;log2 GATA3 expression&quot;,
    y = &quot;log2 ESR1 expression&quot;,
    colour = &quot;ER status&quot;
  )
plot</code></pre>
<pre><code>## `geom_smooth()` using formula = &#39;y ~ x&#39;</code></pre>
<p><img src="week6_files/figure-html/scatter_plot_1-1.png" width="672" /></p>
<p>The labels are another component of the plot object that we’ve
constructed, along with aesthetic mappings and layers (geoms). The plot
object is a list and contains various elements including those mappings
and layers and one element named <code>labels</code>.</p>
<p><code>labs()</code> is a simple function for creating a list of
labels you want to specify as name-value pairs as in the above example.
You can name any aesthetic (in this case x and y) to override the
default values (the column names) and you can add a title, subtitle and
caption if you wish. In addition to changing the x- and y-axis labels,
we also removed the underscore from the legend title by setting the
label for the colour aesthetic.</p>
</div>
<div id="scales" class="section level2">
<h2>Scales</h2>
<p>Take a look at the x and y scales in the above plot. ggplot2 has
chosen the x and y scales and where to put breaks and ticks.</p>
<p>Let’s have a look at the elements of the list object we created that
specifies how the plot should be displayed.</p>
<pre class="r"><code>names(plot)</code></pre>
<pre><code>## [1] &quot;data&quot;        &quot;layers&quot;      &quot;scales&quot;      &quot;mapping&quot;     &quot;theme&quot;      
## [6] &quot;coordinates&quot; &quot;facet&quot;       &quot;plot_env&quot;    &quot;labels&quot;</code></pre>
<p>One of the components of the plot is called <code>scales</code>.
ggplot2 automatically adds default scales behind the scenes equivalent
to the following:</p>
<pre class="r"><code>plot &lt;- ggplot(data = metabric, mapping = aes(x = GATA3, y = ESR1, colour = ER_status)) +
  geom_point(size = 0.6, alpha = 0.5) +
  geom_smooth(method = &quot;lm&quot;) +
  scale_x_continuous() +
  scale_y_continuous() +
  scale_colour_discrete()</code></pre>
<p>Note that we have three aesthetics and ggplot2 adds a scale for
each.</p>
<pre class="r"><code>plot$mapping</code></pre>
<pre><code>## Aesthetic mapping: 
## * `x`      -&gt; `GATA3`
## * `y`      -&gt; `ESR1`
## * `colour` -&gt; `ER_status`</code></pre>
<p>The x and y variables (<code>GATA3</code> and <code>ESR1</code>) are
continuous so ggplot2 adds a continuous scale for each.
<code>ER_status</code> is a discrete variable in this case so ggplot2
adds a discrete scale for colour.</p>
<p>Generalizing, the scales that are required follow the naming
scheme:</p>
<pre><code>scale_&lt;NAME_OF_AESTHETIC&gt;_&lt;NAME_OF_SCALE&gt;</code></pre>
<p>Look at the help page for <code>scale_y_continuous</code> to see what
we can change about the y-axis scale.</p>
<p>First we’ll change the breaks, i.e. where ggplot2 puts ticks and
numeric labels, on the y axis.</p>
<pre class="r"><code>ggplot(data = metabric, mapping = aes(x = GATA3, y = ESR1, colour = ER_status)) +
  geom_point(size = 0.6, alpha = 0.5) +
  geom_smooth(method = &quot;lm&quot;) +
  scale_y_continuous(breaks = seq(5, 15, by = 2.5))</code></pre>
<pre><code>## `geom_smooth()` using formula = &#39;y ~ x&#39;</code></pre>
<p><img src="week6_files/figure-html/scatter_plot_2-1.png" width="672" /></p>
<p><code>seq()</code> is a useful function for generating regular
sequences of numbers. In this case we wanted numbers from 5 to 15 going
up in steps of 2.5.</p>
<pre class="r"><code>seq(5, 15, by = 2.5)</code></pre>
<pre><code>## [1]  5.0  7.5 10.0 12.5 15.0</code></pre>
<p>We could do the same thing for the x axis using
<code>scale_x_continuous()</code>.</p>
<p>We can also adjust the extents of the x or y axis.</p>
<pre class="r"><code>ggplot(data = metabric, mapping = aes(x = GATA3, y = ESR1, colour = ER_status)) +
  geom_point(size = 0.6, alpha = 0.5) +
  geom_smooth(method = &quot;lm&quot;) +
  scale_y_continuous(breaks = seq(5, 15, by = 2.5), limits = c(4, 12))</code></pre>
<pre><code>## `geom_smooth()` using formula = &#39;y ~ x&#39;</code></pre>
<pre><code>## Warning: Removed 160 rows containing non-finite values (`stat_smooth()`).</code></pre>
<pre><code>## Warning: Removed 160 rows containing missing values (`geom_point()`).</code></pre>
<p><img src="week6_files/figure-html/scatter_plot_3-1.png" width="672" /></p>
<p>Here, just for demonstration purposes, we set the upper limit to be
less than the largest values of ESR1 expression and ggplot2 warned us
that some rows have been removed from the plot.</p>
<p>We can change the minor breaks, e.g. to add more lines that act as
guides. These are shown as thin white lines when using the default theme
(we’ll take a look at alternative themes next week).</p>
<pre class="r"><code>ggplot(data = metabric, mapping = aes(x = GATA3, y = ESR1, colour = ER_status)) +
  geom_point(size = 0.6, alpha = 0.5) +
  geom_smooth(method = &quot;lm&quot;) +
  scale_y_continuous(breaks = seq(5, 12.5, by = 2.5), minor_breaks = seq(5, 13.5, 0.5), limits = c(5, 13.5))</code></pre>
<pre><code>## `geom_smooth()` using formula = &#39;y ~ x&#39;</code></pre>
<p><img src="week6_files/figure-html/scatter_plot_4-1.png" width="672" /></p>
<p>Or we can remove the minor breaks entirely.</p>
<pre class="r"><code>ggplot(data = metabric, mapping = aes(x = GATA3, y = ESR1, colour = ER_status)) +
  geom_point(size = 0.6, alpha = 0.5) +
  geom_smooth(method = &quot;lm&quot;) +
  scale_y_continuous(breaks = seq(6, 14, by = 2), minor_breaks = NULL, limits = c(5, 13.5))</code></pre>
<pre><code>## `geom_smooth()` using formula = &#39;y ~ x&#39;</code></pre>
<p><img src="week6_files/figure-html/scatter_plot_5-1.png" width="672" /></p>
<p>Similarly we could remove all breaks entirely.</p>
<pre class="r"><code>ggplot(data = metabric, mapping = aes(x = GATA3, y = ESR1, colour = ER_status)) +
  geom_point(size = 0.6, alpha = 0.5) +
  geom_smooth(method = &quot;lm&quot;) +
  scale_y_continuous(breaks = NULL)</code></pre>
<pre><code>## `geom_smooth()` using formula = &#39;y ~ x&#39;</code></pre>
<p><img src="week6_files/figure-html/scatter_plot_6-1.png" width="672" /></p>
<p>A more typical scenario would be to keep the breaks, because we want
to display the ticks and their lables, but remove the grid lines.
Somewhat confusingly the position of grid lines are controlled by a
scale but preventing these from being displayed requires changing the
theme. The theme controls the way in which non-data components are
displayed – we’ll look at how these can be customized next week. For
now, though, here’s an example of turning off the display of all grid
lines for major and minor breaks for both axes.</p>
<pre class="r"><code>ggplot(data = metabric, mapping = aes(x = GATA3, y = ESR1, colour = ER_status)) +
  geom_point(size = 0.6, alpha = 0.5) +
  geom_smooth(method = &quot;lm&quot;) +
  scale_y_continuous(breaks = seq(4, 14, by = 2), limits = c(4, 14)) +
  theme(panel.grid = element_blank())</code></pre>
<pre><code>## `geom_smooth()` using formula = &#39;y ~ x&#39;</code></pre>
<p><img src="week6_files/figure-html/scatter_plot_7-1.png" width="672" /></p>
<p>By default, the scales are expanded by 5% of the range on either
side. We can add or reduce the space as follows.</p>
<pre class="r"><code>ggplot(data = metabric, mapping = aes(x = GATA3, y = ESR1, colour = ER_status)) +
  geom_point(size = 0.6, alpha = 0.5) +
  geom_smooth(method = &quot;lm&quot;) +
  scale_x_continuous(expand = expand_scale(mult = 0.01)) +
  scale_y_continuous(expand = expand_scale(mult = 0.25))</code></pre>
<pre><code>## Warning: `expand_scale()` was deprecated in ggplot2 3.3.0.
## ℹ Please use `expansion()` instead.
## This warning is displayed once every 8 hours.
## Call `lifecycle::last_lifecycle_warnings()` to see where this warning was
## generated.</code></pre>
<pre><code>## `geom_smooth()` using formula = &#39;y ~ x&#39;</code></pre>
<p><img src="week6_files/figure-html/scatter_plot_8-1.png" width="672" /></p>
<p>Here we only added 1% (0.01) of the range of GATA3 expression values
on either side along the x axis but we added 25% (0.25) of the range of
ESR1 expression on either side along the y axis.</p>
<p>We can move the axis to the other side of the plot –- not sure why
you’d want to do this but with ggplot2 just about anything is
possible.</p>
<pre class="r"><code>ggplot(data = metabric, mapping = aes(x = GATA3, y = ESR1, colour = ER_status)) +
  geom_point(size = 0.6, alpha = 0.5) +
  geom_smooth(method = &quot;lm&quot;) +
  scale_x_continuous(position = &quot;top&quot;)</code></pre>
<pre><code>## `geom_smooth()` using formula = &#39;y ~ x&#39;</code></pre>
<p><img src="week6_files/figure-html/scatter_plot_9-1.png" width="672" /></p>
</div>
<div id="colours" class="section level2">
<h2>Colours</h2>
<p>The colour asthetic is used with a categorical variable,
<code>ER_status</code>, in the scatter plots we’ve been customizing. The
default colour scale used by ggplot2 for categorical variables is
<code>scale_colour_discrete</code>. We can manually set the colours we
wish to use using <code>scale_colour_manual</code> instead.</p>
<pre class="r"><code>ggplot(data = metabric, mapping = aes(x = GATA3, y = ESR1, colour = ER_status)) +
  geom_point(size = 0.6, alpha = 0.5) +
  geom_smooth(method = &quot;lm&quot;) +
  scale_colour_manual(values = c(&quot;dodgerblue2&quot;, &quot;firebrick2&quot;))</code></pre>
<pre><code>## `geom_smooth()` using formula = &#39;y ~ x&#39;</code></pre>
<p><img src="week6_files/figure-html/scatter_plot_10-1.png" width="672" /></p>
<p>Setting colours manually is ok when we only have two or three
categories but when we have a larger number it would be handy to be able
to choose from a selection of carefully-constructed colour palettes.
Helpfully, ggplot2 provides access to the <a
href="http://colorbrewer2.org">ColorBrewer</a> palettes through the
functions <code>scale_colour_brewer()</code> and
<code>scale_fill_brewer()</code>.</p>
<pre class="r"><code>ggplot(data = metabric, mapping = aes(x = GATA3, y = ESR1, colour = `3-gene_classifier`)) +
  geom_point(size = 0.6, alpha = 0.5, na.rm = TRUE) +
  scale_colour_brewer(palette = &quot;Set1&quot;)</code></pre>
<p><img src="week6_files/figure-html/scatter_plot_11-1.png" width="672" /></p>
<p>Look at the help page for <code>scale_colour_brewer</code> to see
what other colour palettes are available and visit the <a
href="http://colorbrewer2.org">ColorBrewer</a> website to see what these
look like.</p>
<p>Interestingly, you can set other attributes other than just the
colours at the same time.</p>
<pre class="r"><code>ggplot(data = metabric, mapping = aes(x = GATA3, y = ESR1, colour = ER_status)) +
  geom_point(size = 0.6, alpha = 0.5) +
  geom_smooth(method = &quot;lm&quot;) +
  scale_colour_manual(values = c(&quot;dodgerblue2&quot;, &quot;firebrick2&quot;), labels = c(&quot;ER-negative&quot;, &quot;ER-positive&quot;)) +
  labs(colour = NULL)  # remove legend title for colour now that the labels are self-explanatory</code></pre>
<pre><code>## `geom_smooth()` using formula = &#39;y ~ x&#39;</code></pre>
<p><img src="week6_files/figure-html/scatter_plot_12-1.png" width="672" /></p>
<p>We have applied our own set of mappings from levels in the data to
aesthetic values.</p>
<p>For continuous variables we may wish to be able to change the colours
used in the colour gradient. To demonstrate this we’ll correct the
Nottingham prognostic index (NPI) values and use this to colour points
in the scatter plot of ESR1 vs GATA3 expression on a continuous
scale.</p>
<pre class="r"><code># Nottingham_prognostic_index is incorrectly calculated in the data downloaded from cBioPortal
metabric &lt;- mutate(metabric, Nottingham_prognostic_index = 0.02 * Tumour_size + Lymph_node_status + Neoplasm_histologic_grade)
#
metabric %&gt;%
  filter(!is.na(Nottingham_prognostic_index)) %&gt;%
  ggplot(mapping = aes(x = GATA3, y = ESR1, colour = Nottingham_prognostic_index)) +
  geom_point(size = 0.5)</code></pre>
<p><img src="week6_files/figure-html/scatter_plot_13-1.png" width="672" /></p>
<p>Higher NPI scores correspond to worse prognosis and lower chance of 5
year survival. We’ll emphasize those points on the scatter plot by
adjusting our colour scale.</p>
<pre class="r"><code>metabric %&gt;%
  filter(!is.na(Nottingham_prognostic_index)) %&gt;%
  ggplot(mapping = aes(x = GATA3, y = ESR1, colour = Nottingham_prognostic_index)) +
  geom_point(size = 0.75) +
  scale_colour_gradient(low = &quot;white&quot;, high = &quot;firebrick2&quot;)</code></pre>
<p><img src="week6_files/figure-html/scatter_plot_14-1.png" width="672" /></p>
<p>In some cases it might make sense to specify two colour gradients
either side of a mid-point.</p>
<pre class="r"><code>metabric %&gt;%
  filter(!is.na(Nottingham_prognostic_index)) %&gt;%
  ggplot(mapping = aes(x = GATA3, y = ESR1, colour = Nottingham_prognostic_index)) +
  geom_point(size = 0.75) +
  scale_colour_gradient2(low = &quot;dodgerblue1&quot;, mid = &quot;grey90&quot;, high = &quot;firebrick1&quot;, midpoint = 4.5)</code></pre>
<p><img src="week6_files/figure-html/scatter_plot_15-1.png" width="672" /></p>
<p>As before we can override the default labels and other aspects of the
colour scale within the scale function.</p>
<pre class="r"><code>metabric %&gt;%
  filter(!is.na(Nottingham_prognostic_index)) %&gt;%
  ggplot(mapping = aes(x = GATA3, y = ESR1, colour = Nottingham_prognostic_index)) +
  geom_point(size = 0.5) +
  scale_colour_gradient(
    low = &quot;lightblue&quot;, high = &quot;darkblue&quot;,
    name = &quot;NPI&quot;,
    breaks = 2:6,
    limits = c(1.5, 6.5)
  )</code></pre>
<p><img src="week6_files/figure-html/scatter_plot_16-1.png" width="672" /></p>
</div>
</div>
<div id="summary" class="section level1">
<h1>Summary</h1>
<p>In this session we have covered the following:</p>
<ul>
<li>Computing summary values for groups of observations</li>
<li>Counting the numbers of observations within categories</li>
<li>Combining data from two tables through join operations</li>
<li>Customizing plots created with ggplot2 by changing labels, scales
and colours</li>
</ul>
</div>
<div id="exercises" class="section level1">
<h1>Exercises</h1>
<div class="exercise">
<ol style="list-style-type: decimal">
<li>Compute the average survival time for the ER-negative and
ER-positive groups. Note that such a comparison only makes sense for
those patients that are deceased so apply the appropriate filter first.
Add a column for the number of patients in each group. You can use
“metabric_clinical_data.csv” file.</li>
</ol>
<!---<details><summary>Answer</summary>

```r
library(tidyverse)
metabric <- read_csv("data/metabric_clinical_data.csv")
metabric %>%
  filter(Survival_status == "DECEASED") %>%
  group_by(ER_status) %>%
  summarize(`Average survival time` = mean(Survival_time), N = n())
```

```
## # A tibble: 2 × 3
##   ER_status `Average survival time`     N
##   <chr>                       <dbl> <int>
## 1 Negative                     66.3   262
## 2 Positive                    111.    882
```

</details>--->
</div>
<div class="exercise">
<ol start="2" style="list-style-type: decimal">
<li>Compute the average tumour size, number of positive lymph nodes and
Nottingham prognostic index within ER-negative and ER-positive
patients.</li>
</ol>
<!---<details><summary>Answer</summary>

```r
library(tidyverse)
metabric <- read_csv("data/metabric_clinical_data.csv")
metabric %>%
  group_by(ER_status) %>%
  summarize_at(vars(Tumour_size, Lymph_nodes_examined_positive, Nottingham_prognostic_index), mean, na.rm = TRUE)
```

```
## # A tibble: 3 × 4
##   ER_status Tumour_size Lymph_nodes_examined_positive Nottingham_prognostic_in…¹
##   <chr>           <dbl>                         <dbl>                      <dbl>
## 1 Negative         28.3                          2.62                       4.60
## 2 Positive         25.4                          1.73                       3.86
## 3 <NA>             35                            1.70                       2.26
## # ℹ abbreviated name: ¹​Nottingham_prognostic_index
```
</details>--->
</div>
<div class="exercise">
<ol start="3" style="list-style-type: decimal">
<li>Count the numbers of mutations for each gene and display the top 10
most frequently mutated genes using metabric_mutations.csv data.</li>
</ol>
<!---<details><summary>Answer</summary>

```r
mutations <- read_csv("data/metabric_mutations.csv")
mutations %>%
  count(Gene) %>%
  arrange(desc(n)) %>%
  head(10)
```

```
## # A tibble: 10 × 2
##    Gene       n
##    <chr>  <int>
##  1 PIK3CA  1122
##  2 TP53     897
##  3 AHNAK2   859
##  4 MUC16    666
##  5 SYNE1    468
##  6 KMT2C    389
##  7 MAP3K1   372
##  8 AHNAK    327
##  9 GATA3    301
## 10 DNAH11   300
```
</details>--->
</div>
<div class="exercise">
<ol start="4" style="list-style-type: decimal">
<li>In breast cancers, PIK3CA and TP53 are the most commonly mutated
genes with mutations occurring in specific regions of the gene. Find out
which codons of PIK3CA are most commonly mutated.</li>
</ol>
<!---<details><summary>Answer</summary>

```r
mutations %>%
  filter(Gene == "PIK3CA") %>%
  count(Codon) %>%
  arrange(desc(n))
```

```
## # A tibble: 88 × 2
##    Codon     n
##    <dbl> <int>
##  1  1047   471
##  2   545   192
##  3   542   101
##  4   345    64
##  5   726    28
##  6   546    26
##  7   420    19
##  8   111    13
##  9  1043    12
## 10   108    10
## # ℹ 78 more rows
```
</details>--->
</div>
<div class="exercise">
<ol start="5" style="list-style-type: decimal">
<li>Use boxplots to illustrate the distribution of diagnosis age for
3-gene classification groups of patients. Remove any patients who are
unclassified. The boxplots should be colored according to the
group.</li>
</ol>
<!---<details><summary>Answer</summary>

```r
metabric %>% 
  filter(!is.na(`3-gene_classifier`)) %>% 
ggplot( mapping=aes(x=`3-gene_classifier`, y=Age_at_diagnosis, colour=`3-gene_classifier`)) +
  geom_boxplot() +
  scale_colour_discrete(name="3 gene classifier")
```

<img src="week6_files/figure-html/unnamed-chunk-49-1.png" width="672" />
</details>--->
</div>
</div>



</div>
</div>

</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.odd').parent('tbody').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- tabsets -->

<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});

$(document).ready(function () {
  $('.tabset-dropdown > .nav-tabs > li').click(function () {
    $(this).parent().toggleClass('nav-tabs-open');
  });
});
</script>

<!-- code folding -->

<script>
$(document).ready(function ()  {

    // temporarily add toc-ignore selector to headers for the consistency with Pandoc
    $('.unlisted.unnumbered').addClass('toc-ignore')

    // move toc-ignore selectors from section div to header
    $('div.section.toc-ignore')
        .removeClass('toc-ignore')
        .children('h1,h2,h3,h4,h5').addClass('toc-ignore');

    // establish options
    var options = {
      selectors: "h1,h2,h3",
      theme: "bootstrap3",
      context: '.toc-content',
      hashGenerator: function (text) {
        return text.replace(/[.\\/?&!#<>]/g, '').replace(/\s/g, '_');
      },
      ignoreSelector: ".toc-ignore",
      scrollTo: 0
    };
    options.showAndHide = true;
    options.smoothScroll = true;

    // tocify
    var toc = $("#TOC").tocify(options).data("toc-tocify");
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
