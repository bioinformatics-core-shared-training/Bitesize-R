<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />




<title>Week 5 – Data manipulation with dplyr</title>

<script src="site_libs/header-attrs-2.29/header-attrs.js"></script>
<script src="site_libs/jquery-3.6.0/jquery-3.6.0.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="site_libs/bootstrap-3.3.5/css/bootstrap.min.css" rel="stylesheet" />
<script src="site_libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/respond.min.js"></script>
<style>h1 {font-size: 34px;}
       h1.title {font-size: 38px;}
       h2 {font-size: 30px;}
       h3 {font-size: 24px;}
       h4 {font-size: 18px;}
       h5 {font-size: 16px;}
       h6 {font-size: 12px;}
       code {color: inherit; background-color: rgba(0, 0, 0, 0.04);}
       pre:not([class]) { background-color: white }</style>
<script src="site_libs/jqueryui-1.13.2/jquery-ui.min.js"></script>
<link href="site_libs/tocify-1.9.1/jquery.tocify.css" rel="stylesheet" />
<script src="site_libs/tocify-1.9.1/jquery.tocify.js"></script>
<script src="site_libs/navigation-1.1/tabsets.js"></script>
<link href="site_libs/highlightjs-9.12.0/default.css" rel="stylesheet" />
<script src="site_libs/highlightjs-9.12.0/highlight.js"></script>
<link href="site_libs/font-awesome-6.5.2/css/all.min.css" rel="stylesheet" />
<link href="site_libs/font-awesome-6.5.2/css/v4-shims.min.css" rel="stylesheet" />

<style type="text/css">
  code{white-space: pre-wrap;}
  span.smallcaps{font-variant: small-caps;}
  span.underline{text-decoration: underline;}
  div.column{display: inline-block; vertical-align: top; width: 50%;}
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  ul.task-list{list-style: none;}
    </style>

<style type="text/css">code{white-space: pre;}</style>
<script type="text/javascript">
if (window.hljs) {
  hljs.configure({languages: []});
  hljs.initHighlightingOnLoad();
  if (document.readyState && document.readyState === "complete") {
    window.setTimeout(function() { hljs.initHighlighting(); }, 0);
  }
}
</script>






<link rel="stylesheet" href="styles.css" type="text/css" />



<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
img {
  max-width:100%;
}
.tabbed-pane {
  padding-top: 12px;
}
.html-widget {
  margin-bottom: 20px;
}
button.code-folding-btn:focus {
  outline: none;
}
summary {
  display: list-item;
}
details > summary > p:only-child {
  display: inline;
}
pre code {
  padding: 0;
}
</style>


<style type="text/css">
.dropdown-submenu {
  position: relative;
}
.dropdown-submenu>.dropdown-menu {
  top: 0;
  left: 100%;
  margin-top: -6px;
  margin-left: -1px;
  border-radius: 0 6px 6px 6px;
}
.dropdown-submenu:hover>.dropdown-menu {
  display: block;
}
.dropdown-submenu>a:after {
  display: block;
  content: " ";
  float: right;
  width: 0;
  height: 0;
  border-color: transparent;
  border-style: solid;
  border-width: 5px 0 5px 5px;
  border-left-color: #cccccc;
  margin-top: 5px;
  margin-right: -10px;
}
.dropdown-submenu:hover>a:after {
  border-left-color: #adb5bd;
}
.dropdown-submenu.pull-left {
  float: none;
}
.dropdown-submenu.pull-left>.dropdown-menu {
  left: -100%;
  margin-left: 10px;
  border-radius: 6px 0 6px 6px;
}
</style>

<script type="text/javascript">
// manage active state of menu based on current page
$(document).ready(function () {
  // active menu anchor
  href = window.location.pathname
  href = href.substr(href.lastIndexOf('/') + 1)
  if (href === "")
    href = "index.html";
  var menuAnchor = $('a[href="' + href + '"]');

  // mark the anchor link active (and if it's in a dropdown, also mark that active)
  var dropdown = menuAnchor.closest('li.dropdown');
  if (window.bootstrap) { // Bootstrap 4+
    menuAnchor.addClass('active');
    dropdown.find('> .dropdown-toggle').addClass('active');
  } else { // Bootstrap 3
    menuAnchor.parent().addClass('active');
    dropdown.addClass('active');
  }

  // Navbar adjustments
  var navHeight = $(".navbar").first().height() + 15;
  var style = document.createElement('style');
  var pt = "padding-top: " + navHeight + "px; ";
  var mt = "margin-top: -" + navHeight + "px; ";
  var css = "";
  // offset scroll position for anchor links (for fixed navbar)
  for (var i = 1; i <= 6; i++) {
    css += ".section h" + i + "{ " + pt + mt + "}\n";
  }
  style.innerHTML = "body {" + pt + "padding-bottom: 40px; }\n" + css;
  document.head.appendChild(style);
});
</script>

<!-- tabsets -->

<style type="text/css">
.tabset-dropdown > .nav-tabs {
  display: inline-table;
  max-height: 500px;
  min-height: 44px;
  overflow-y: auto;
  border: 1px solid #ddd;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs > li.active:before, .tabset-dropdown > .nav-tabs.nav-tabs-open:before {
  content: "\e259";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li.active:before {
  content: "\e258";
  font-family: 'Glyphicons Halflings';
  border: none;
}

.tabset-dropdown > .nav-tabs > li.active {
  display: block;
}

.tabset-dropdown > .nav-tabs > li > a,
.tabset-dropdown > .nav-tabs > li > a:focus,
.tabset-dropdown > .nav-tabs > li > a:hover {
  border: none;
  display: inline-block;
  border-radius: 4px;
  background-color: transparent;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li {
  display: block;
  float: none;
}

.tabset-dropdown > .nav-tabs > li {
  display: none;
}
</style>

<!-- code folding -->



<style type="text/css">

#TOC {
  margin: 25px 0px 20px 0px;
}
@media (max-width: 768px) {
#TOC {
  position: relative;
  width: 100%;
}
}

@media print {
.toc-content {
  /* see https://github.com/w3c/csswg-drafts/issues/4434 */
  float: right;
}
}

.toc-content {
  padding-left: 30px;
  padding-right: 40px;
}

div.main-container {
  max-width: 1200px;
}

div.tocify {
  width: 20%;
  max-width: 260px;
  max-height: 85%;
}

@media (min-width: 768px) and (max-width: 991px) {
  div.tocify {
    width: 25%;
  }
}

@media (max-width: 767px) {
  div.tocify {
    width: 100%;
    max-width: none;
  }
}

.tocify ul, .tocify li {
  line-height: 20px;
}

.tocify-subheader .tocify-item {
  font-size: 0.90em;
}

.tocify .list-group-item {
  border-radius: 0px;
}


</style>



</head>

<body>


<div class="container-fluid main-container">


<!-- setup 3col/9col grid for toc_float and main content  -->
<div class="row">
<div class="col-xs-12 col-sm-4 col-md-3">
<div id="TOC" class="tocify">
</div>
</div>

<div class="toc-content col-xs-12 col-sm-8 col-md-9">




<div class="navbar navbar-default  navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-bs-toggle="collapse" data-target="#navbar" data-bs-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="index.html"><img style="width: 120px; float: left; margin-top: 0px; margin-right: 20px;" src="images/CRUK_CI_logo.png"/>R for Biologists&nbsp;&nbsp;&nbsp;</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">
    Contents
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="week1.html">Week 1 - Introduction to R</a>
    </li>
    <li>
      <a href="week2.html">Week 2 - Introduction to R data structures</a>
    </li>
    <li>
      <a href="week3.html">Week 3 - Working with data in R</a>
    </li>
    <li>
      <a href="week4.html">Week 4 - Data visualization with ggplot2</a>
    </li>
    <li>
      <a href="week5.html">Week 5 - Data manipulation using dplyr</a>
    </li>
    <li>
      <a href="week6.html">Week 6 - Grouping and combining data</a>
    </li>
    <li>
      <a href="week8.html">Week 8 - Restructuring data for analysis</a>
    </li>
  </ul>
</li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        <li>
  <a href="https://github.com/bioinformatics-core-shared-training/Bitesize-R">
    <span class="fa fa-github fa-lg"></span>
     
  </a>
</li>
      </ul>
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

<div id="header">



<h1 class="title toc-ignore">Week 5 – Data manipulation with dplyr</h1>

</div>


<blockquote>
<h4 id="learning-objectives">Learning objectives</h4>
<ul>
<li>Chain operations together into a workflow using pipes</li>
<li>Learn the key <strong>dplyr</strong> functions for manipulating your
data</li>
<li>Learn about faceting in ggplot2 to split your data into separate
categories and create a series of sub-plots arranged in a grid</li>
</ul>
</blockquote>
<hr />
<div id="data-manipulation-with-dplyr" class="section level1">
<h1>Data manipulation with dplyr</h1>
<p><strong>dplyr</strong> is one of the packages that gets loaded as
part of the tidyverse.</p>
<pre class="r"><code>library(tidyverse)</code></pre>
<pre><code>## ── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──
## ✔ dplyr     1.1.4     ✔ readr     2.1.5
## ✔ forcats   1.0.0     ✔ stringr   1.5.1
## ✔ ggplot2   3.5.1     ✔ tibble    3.2.1
## ✔ lubridate 1.9.4     ✔ tidyr     1.3.1
## ✔ purrr     1.0.4     
## ── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──
## ✖ dplyr::filter() masks stats::filter()
## ✖ dplyr::lag()    masks stats::lag()
## ℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors</code></pre>
<p>dplyr is the Swiss army knife in the tidyverse, providing many useful
functions for manipulating tabular data in data frames or tibbles. We’re
going to look at the key functions for filtering our data, modifying the
contents and computing summary statistics.</p>
<p>We’ll also introduce the pipe operator,
<strong><code>%&gt;%</code></strong>, for chaining operations together
into mini workflows in a way that makes for more readable and
maintainable code.</p>
<p>Finally, we’ll return to plotting and look at a powerful feature of
ggplot2, <strong>faceting</strong>, that allows you to divide your plots
into subplots by splitting the observations based on one or more
categorical variables.</p>
<p>We’ll again use the METABRIC data set to illustrate how these
operations work.</p>
<pre class="r"><code>metabric &lt;- read_csv(&quot;data/metabric_clinical_and_expression_data.csv&quot;)
metabric</code></pre>
<pre><code>## # A tibble: 1,904 × 32
##    Patient_ID Cohort Age_at_diagnosis Survival_time Survival_status Vital_status
##    &lt;chr&gt;       &lt;dbl&gt;            &lt;dbl&gt;         &lt;dbl&gt; &lt;chr&gt;           &lt;chr&gt;       
##  1 MB-0000         1             75.6         140.  LIVING          Living      
##  2 MB-0002         1             43.2          84.6 LIVING          Living      
##  3 MB-0005         1             48.9         164.  DECEASED        Died of Dis…
##  4 MB-0006         1             47.7         165.  LIVING          Living      
##  5 MB-0008         1             77.0          41.4 DECEASED        Died of Dis…
##  6 MB-0010         1             78.8           7.8 DECEASED        Died of Dis…
##  7 MB-0014         1             56.4         164.  LIVING          Living      
##  8 MB-0022         1             89.1          99.5 DECEASED        Died of Oth…
##  9 MB-0028         1             86.4          36.6 DECEASED        Died of Oth…
## 10 MB-0035         1             84.2          36.3 DECEASED        Died of Dis…
## # ℹ 1,894 more rows
## # ℹ 26 more variables: Chemotherapy &lt;chr&gt;, Radiotherapy &lt;chr&gt;,
## #   Tumour_size &lt;dbl&gt;, Tumour_stage &lt;dbl&gt;, Neoplasm_histologic_grade &lt;dbl&gt;,
## #   Lymph_nodes_examined_positive &lt;dbl&gt;, Lymph_node_status &lt;dbl&gt;,
## #   Cancer_type &lt;chr&gt;, ER_status &lt;chr&gt;, PR_status &lt;chr&gt;, HER2_status &lt;chr&gt;,
## #   HER2_status_measured_by_SNP6 &lt;chr&gt;, PAM50 &lt;chr&gt;, `3-gene_classifier` &lt;chr&gt;,
## #   Nottingham_prognostic_index &lt;dbl&gt;, Cellularity &lt;chr&gt;, …</code></pre>
<hr />
</div>
<div id="dplyr-verbs" class="section level1">
<h1>dplyr verbs</h1>
<p>The dplyr operations are commonly referred to as “verbs” in a data
manipulation grammar. These verbs have a common syntax and work together
in a consistent and uniform manner. They all have the following shared
behaviours:</p>
<ul>
<li><p>The first argument in each function is a data frame (or
tibble)</p></li>
<li><p>Any additional arguments describe what operation to perform on
the data frame</p></li>
<li><p>Variable names, i.e. column names, are referred to without using
quotes</p></li>
<li><p>The result of an operation is a new data frame</p></li>
</ul>
<hr />
</div>
<div id="chaining-operations-using" class="section level1">
<h1>Chaining operations using <code>%&gt;%</code></h1>
<p>Let’s consider again an earlier example in which we filtered the
METABRIC data set to retain just the patients who were still alive at
the time of the study and had survived for more than 10 years (120
months). We use <code>filter()</code> to select the rows corresponding
to the patients meeting these criteria and can then use
<code>select()</code> to only display the variables (columns) we’re most
interested in.</p>
<pre class="r"><code>patients &lt;- filter(metabric,
                   Survival_status == &quot;LIVING&quot; &amp; Survival_time &gt; 120)
patient_details &lt;- select(patients,
                          Patient_ID,
                          Survival_time,
                          Tumour_stage,
                          Nottingham_prognostic_index)
patient_details</code></pre>
<pre><code>## # A tibble: 545 × 4
##    Patient_ID Survival_time Tumour_stage Nottingham_prognostic_index
##    &lt;chr&gt;              &lt;dbl&gt;        &lt;dbl&gt;                       &lt;dbl&gt;
##  1 MB-0000             140.            2                        6.04
##  2 MB-0006             165.            2                        4.05
##  3 MB-0014             164.            2                        4.02
##  4 MB-0039             164.            1                        2.04
##  5 MB-0045             165.            2                        5.04
##  6 MB-0053             161.            2                        3.05
##  7 MB-0054             160.            2                        4.07
##  8 MB-0060             141.            2                        4.05
##  9 MB-0062             154.            1                        4.03
## 10 MB-0066             157.            2                        4.03
## # ℹ 535 more rows</code></pre>
<p>Here we’ve used an intermediate variable, <code>patients</code>,
which we only needed in order to get to the final result. We could just
have used the same name to avoid cluttering our environment and
overwritten the results from the <code>filter()</code> operation with
those of the <code>select()</code> operation.</p>
<pre class="r"><code>patients &lt;- select(patients,
                   Patient_ID,
                   Survival_time,
                   Tumour_stage,
                   Nottingham_prognostic_index)</code></pre>
<p>In order to avoid creating intermediate objects, another less
readable way of writing this code is to nest the <code>filter()</code>
function call inside the <code>select()</code>. Nested function calls
are very common in a lot of R code you may come across. For example,
imagine we have a vector of numbers and we want to find the square root
of the mean. We could do it two steps:</p>
<pre class="r"><code>x &lt;- c(24, 53, 352, 643, 46)
myMean &lt;- mean(x)
sqrt(myMean)</code></pre>
<pre><code>## [1] 14.95326</code></pre>
<p>Or we can nest the commands inside each other:</p>
<pre class="r"><code>sqrt(mean(x))</code></pre>
<pre><code>## [1] 14.95326</code></pre>
<p>This is convenient for simple commands, but is unwieldy and not easy
to read with more complex commands:</p>
<pre class="r"><code>patients &lt;- select(filter(metabric, Survival_status == &quot;LIVING&quot;, Survival_time &gt; 120), Patient_ID, Survival_time, Tumour_stage, Nottingham_prognostic_index)
nrow(patients)</code></pre>
<pre><code>## [1] 545</code></pre>
<p>However, there is another way chaining together a series of
operations into a mini workflow that is elegant, intuitive and makes for
very readable R code. For that we need to introduce a new operator, the
<strong>pipe</strong> operator,
<strong><code>%&gt;%</code></strong>.</p>
<div class="rmdblock">
<p>
<strong>The pipe operator <code>%&gt;%</code></strong>
</p>
<p>
The pipe operator takes the output from one operation, i.e. whatever is
on the left-hand side of <code>%&gt;%</code> and passes it in as the
first argument to the second operation, or function, on the right-hand
side.
</p>
<p>
<strong><code>x %&gt;% f(y)</code></strong> is equivalent to
<strong><code>f(x, y)</code></strong>
</p>
<p>
For example:
</p>
<p>
<code>select(starwars, name, height, mass)</code>
</p>
<p>
can be rewritten as
</p>
<p>
<code>starwars %&gt;% select(name, height, mass)</code>
</p>
<p>
This allows for chaining of operations into workflows, e.g.
</p>
<p>
<code>starwars %&gt;%</code><br/>     <code>filter(species == “Droid”)
%&gt;%</code><br/>     <code>select(name, height, mass)</code>
</p>
<p>
The <code>%&gt;%</code> operator comes from the <code>magrittr</code>
package and is available when we load the tidyverse using
<code>library(tidyverse)</code>.
</p>
<p>
Piping in R was motivated by the Unix pipe, <code>|</code>, in which the
output from one process is redirected to be the input for the next. This
is so named because the flow from one process or operation to the next
resembles a pipeline.
</p>
<p>
NOTE: The <code>%&gt;%</code> operator is from the packages
<strong>magrittr</strong>. R now has a native pipe operator,
<code>|&gt;</code>, but we’ll stick with the
<strong><code>%&gt;%</code></strong> operator as it is more widely used
and has a few advantages over the native pipe.
</p>
</div>
<p>We can rewrite the code for our filtering and column selection
operations as follows.</p>
<pre class="r"><code>patients &lt;- metabric %&gt;%
    filter(Survival_status == &quot;LIVING&quot; &amp; Survival_time &gt; 120) %&gt;%
    select(Patient_ID, Survival_time, Tumour_stage, Nottingham_prognostic_index)</code></pre>
<p>Note how each operation takes the output from the previous operation
as its first argument. This way of coding is embraced wholeheartedly in
the tidyverse hence almost every tidyverse function that works on data
frames has the data frame as its first argument. It is also the reason
why tidyverse functions return a data frame regardless of whether the
output could be recast as a vector or a single value.</p>
<p>“Piping”, the act of chaining operations together, becomes really
useful when there are several steps involved in filtering and
transforming a data set.</p>
<p>The usual way of developing a workflow is to build it up one step at
a time, testing the output produced at each stage. Let’s do that for
this case.</p>
<p>We start by considering just the patients who are living.</p>
<pre class="r"><code>patients &lt;- metabric %&gt;%
    filter(Survival_status == &quot;LIVING&quot;)</code></pre>
<p>We then add another filter for the survival time.</p>
<pre class="r"><code>patients &lt;- metabric %&gt;%
    filter(Survival_status == &quot;LIVING&quot;) %&gt;%
    filter(Survival_time &gt; 120)</code></pre>
<p>At each stage we look at the resulting <code>patients</code> data
frame to check we’re happy with the result.</p>
<p>Finally we only want certain columns, so we add a
<code>select()</code> operation.</p>
<pre class="r"><code>patients &lt;- metabric %&gt;%
    filter(Survival_status == &quot;LIVING&quot;) %&gt;%
    filter(Survival_time &gt; 120) %&gt;%
    select(Patient_ID, Survival_time, Tumour_stage, Nottingham_prognostic_index)
# print out the result
patients</code></pre>
<pre><code>## # A tibble: 545 × 4
##    Patient_ID Survival_time Tumour_stage Nottingham_prognostic_index
##    &lt;chr&gt;              &lt;dbl&gt;        &lt;dbl&gt;                       &lt;dbl&gt;
##  1 MB-0000             140.            2                        6.04
##  2 MB-0006             165.            2                        4.05
##  3 MB-0014             164.            2                        4.02
##  4 MB-0039             164.            1                        2.04
##  5 MB-0045             165.            2                        5.04
##  6 MB-0053             161.            2                        3.05
##  7 MB-0054             160.            2                        4.07
##  8 MB-0060             141.            2                        4.05
##  9 MB-0062             154.            1                        4.03
## 10 MB-0066             157.            2                        4.03
## # ℹ 535 more rows</code></pre>
<p>When continuing our workflow across multiple lines, we need to be
careful to ensure the <code>%&gt;%</code> is at the end of the line. If
we try to place this at the start of the next line, R will think we’ve
finished the workflow prematurely and will report an error at what it
considers the next statement, i.e. the line that begins with
<code>%&gt;%</code>.</p>
<pre><code># R considers the following to be 2 separate commands, the first of which ends
# with the first filter operation and runs successfully.
# The second statement is the third and last line, is not a valid commmand and
# so you&#39;ll get an error message
patients &lt;- metabric %&gt;%
    filter(Survival_status == &quot;LIVING&quot;)
    %&gt;% filter(Survival_time &gt; 120)</code></pre>
<p>This is very similar to what we saw with adding layers and other
components to a ggplot using the <code>+</code> operator, where we
needed the <code>+</code> to be at the end of a line.</p>
<p>We’ll be using the pipe <code>%&gt;%</code> operator throughout the
rest of the course so you’d better get used to it. But actually we think
you’ll come to love it as much as we do.</p>
<hr />
</div>
<div id="modifying-data-using-mutate" class="section level1">
<h1>Modifying data using <code>mutate()</code></h1>
<p>In one of the examples of filtering observations using
<code>filter()</code> above, we created a new logical variable called
<code>Deceased</code>.</p>
<p><code>{r}html_document" metabric$Deceased &lt;- metabric$Survival_status == "DECEASED"</code></p>
<p>This is an example of a rather common type of data manipulation in
which we create a new column based on the values contained in one or
more other columns. The <code>dplyr</code> package provides the
<code>mutate()</code> function for this purpose.</p>
<pre class="r"><code>metabric &lt;- mutate(metabric, Deceased = Survival_status == &quot;DECEASED&quot;)</code></pre>
<p>Both of these methods adds the new column to the end.</p>
<p>Note that variables names in the <code>mutate()</code> function call
do not need to be prefixed by <code>metabric$</code> just as they don’t
in any of the <code>dplyr</code> functions.</p>
<p>We can overwrite a column and this is quite commonly done when we
want to change the units. For example, our tumour size values are in
millimetres but the formula for the Nottingham prognostic index needs
the tumour size to be in centimetres. We can convert to
<code>Tumour_size</code> to centimetres by dividing by 10.</p>
<pre class="r"><code>metabric &lt;- mutate(metabric, Tumour_size = Tumour_size / 10)</code></pre>
<div class="rmdblock">
<p>
<strong>Nottingham Prognostic Index</strong>
</p>
<p>
The Nottingham prognostic index (<strong>NPI</strong>) is used to
determine prognosis following surgery for breast cancer. Its value is
calculated using three pathological criteria: the size of the tumour,
the number of lymph nodes involved, and the grade of the tumour.
</p>
<p>
The formula for the Nottingham prognostic index is:
</p>
<p>
<strong><code>NPI = (0.2 * S) + N + G</code></strong>
</p>
<p>
where
</p>
<ul>
<li>
<strong>S</strong> is the size of the tumour in centimetres
</li>
<li>
<strong>N</strong> is the node status (0 nodes = 1, 1-3 nodes = 2, &gt;3
nodes = 3)
</li>
<li>
<strong>G</strong> is the grade of tumour (Grade I = 1, Grade II = 2,
Grade III = 3)
</li>
</ul>
</div>
<p>We’ll recalculate the Nottingham prognostic index using the values
<code>Tumour_size</code>, <code>Neoplasm_histologic_grade</code> and
<code>Lymph_node_status</code> columns in our METABRIC data frame.</p>
<pre class="r"><code>metabric &lt;- metabric %&gt;%
    mutate(NPI = (0.2 * Tumour_size) +
               Lymph_node_status +
               Neoplasm_histologic_grade)

select(metabric,
       Tumour_size,
       Lymph_node_status,
       Neoplasm_histologic_grade,
       NPI,
       Nottingham_prognostic_index)</code></pre>
<pre><code>## # A tibble: 1,904 × 5
##    Tumour_size Lymph_node_status Neoplasm_histologic_grade   NPI
##          &lt;dbl&gt;             &lt;dbl&gt;                     &lt;dbl&gt; &lt;dbl&gt;
##  1         2.2                 3                         3  6.44
##  2         1                   1                         3  4.2 
##  3         1.5                 2                         2  4.3 
##  4         2.5                 2                         2  4.5 
##  5         4                   3                         3  6.8 
##  6         3.1                 1                         3  4.62
##  7         1                   2                         2  4.2 
##  8         2.9                 2                         2  4.58
##  9         1.6                 2                         3  5.32
## 10         2.8                 1                         2  3.56
## # ℹ 1,894 more rows
## # ℹ 1 more variable: Nottingham_prognostic_index &lt;dbl&gt;</code></pre>
<p>There is a discrepency. Can you see what the problem is?</p>
<p>It appears that the tumour size wasn’t correctly converted into
centimetres in the original NPI calculation or that the wrong scaling
factor for tumour size was used.</p>
<pre class="r"><code>ggplot(data = metabric) +
    geom_point(mapping = aes(x = Age_at_diagnosis, y = NPI), na.rm = TRUE)</code></pre>
<p><img src="week5_files/figure-html/scatter_plot_1-1.png" width="672" /></p>
<p>The <strong><code>round()</code></strong> function is really useful
for rounding numerical values to a specified number of decimal places.
We’ll read in the METABRIC data again and create a small workflow that
carries out the tumour size conversion, computes the NPI, rounds the
tumour size and the resulting NPI value to 1 decimal place and displays
the results in decreasing order of NPI.</p>
<pre class="r"><code>read_csv(&quot;data/metabric_clinical_and_expression_data.csv&quot;) %&gt;%
    mutate(Tumour_size = Tumour_size / 10) %&gt;%
    mutate(NPI = (0.2 * Tumour_size) +
               Lymph_node_status +
               Neoplasm_histologic_grade) %&gt;%
    mutate(Tumour_size = round(Tumour_size, digits = 1)) %&gt;%
    mutate(NPI = round(NPI, digits = 1)) %&gt;%
    arrange(desc(NPI)) %&gt;%
    select(Tumour_size, Lymph_node_status, Neoplasm_histologic_grade, NPI)</code></pre>
<pre><code>## # A tibble: 1,904 × 4
##    Tumour_size Lymph_node_status Neoplasm_histologic_grade   NPI
##          &lt;dbl&gt;             &lt;dbl&gt;                     &lt;dbl&gt; &lt;dbl&gt;
##  1        18                   3                         3   9.6
##  2        16                   3                         3   9.2
##  3        15                   3                         3   9  
##  4        13                   3                         3   8.6
##  5        18.2                 2                         3   8.6
##  6        12                   3                         3   8.4
##  7        10                   3                         3   8  
##  8         9.9                 3                         3   8  
##  9         9.9                 3                         3   8  
## 10         8.4                 3                         3   7.7
## # ℹ 1,894 more rows</code></pre>
<div id="mutating-multiple-columns" class="section level2">
<h2>Mutating multiple columns</h2>
<p>In that last workflow we included the same rounding operation applied
to two different variables. It would be nice to be able to carry out
just the one <code>mutate()</code> but apply it to both
<code>Tumour_size</code> and <code>NPI</code> columns and we can using
<strong><code>across()</code></strong>.</p>
<p><code>across</code> is used inside <code>mutate</code> and takes two
arguments, first a selection of columns to operate across and second a
function to apply to those columns.</p>
<p>So if we just wanted to round to the the nearest integer:</p>
<pre class="r"><code>metabric %&gt;%
    mutate(across(c(Tumour_size, NPI), round)) %&gt;%
    select(Patient_ID, Tumour_size, NPI)</code></pre>
<pre><code>## # A tibble: 1,904 × 3
##    Patient_ID Tumour_size   NPI
##    &lt;chr&gt;            &lt;dbl&gt; &lt;dbl&gt;
##  1 MB-0000              2     6
##  2 MB-0002              1     4
##  3 MB-0005              2     4
##  4 MB-0006              2     4
##  5 MB-0008              4     7
##  6 MB-0010              3     5
##  7 MB-0014              1     4
##  8 MB-0022              3     5
##  9 MB-0028              2     5
## 10 MB-0035              3     4
## # ℹ 1,894 more rows</code></pre>
<p>This applies the function <code>round</code> across all columns
specified in the first argument for <code>across</code>.</p>
<p>This is nice and simple but things can get a little more complex if
we want more than just a straightforward function.</p>
<p>We may come across situations where we’d like to apply the same
operation to multiple columns but where there is no available function
in R to do what we want or situations we need to pass extra arguments to
our function.</p>
<p>In these cases the syntax get a little trickier. We need to write
what is known as an “anonymous function”.</p>
<p>Let’s say we want to convert the petal and sepal measurements in the
<code>iris</code> data set from centimetres to millimetres. We’d either
need to create a new function to do this conversion or we could use what
is known as an anonymous function.</p>
<p>There is no ‘multiply by 10’ function and it seems a bit pointless to
create one just for this conversion so we’ll use an anonymous function
instead – anonymous because it has no name, it’s an <em>in situ</em>
function only used in our <code>mutate()</code> function call.</p>
<pre class="r"><code>iris %&gt;%
    as_tibble() %&gt;%
    mutate(across(Sepal.Length:Petal.Width, ~ .x * 10))</code></pre>
<pre><code>## # A tibble: 150 × 5
##    Sepal.Length Sepal.Width Petal.Length Petal.Width Species
##           &lt;dbl&gt;       &lt;dbl&gt;        &lt;dbl&gt;       &lt;dbl&gt; &lt;fct&gt;  
##  1           51          35           14           2 setosa 
##  2           49          30           14           2 setosa 
##  3           47          32           13           2 setosa 
##  4           46          31           15           2 setosa 
##  5           50          36           14           2 setosa 
##  6           54          39           17           4 setosa 
##  7           46          34           14           3 setosa 
##  8           50          34           15           2 setosa 
##  9           44          29           14           2 setosa 
## 10           49          31           15           1 setosa 
## # ℹ 140 more rows</code></pre>
<p>The <strong><code>~</code></strong> denotes that we’re using an
anonymous function (it is the symbol for formulae in R) and the
<code>.x</code> is a placeholder for the column being operated on. In
this case, we’re multiplying each of the columns between
<code>Sepal.Length</code> and <code>Petal.Width</code> inclusive by
10.</p>
<p>If we wish to use an existing function but provide additional
arguments, then the syntax is:</p>
<p><code>~func(.x, ...)</code></p>
<p>Where <code>.x</code> is going to be replaced with the column names
and <code>...</code> is the extra arguments we need to add.</p>
<p>So if we want to round to 1 decimal place:</p>
<pre class="r"><code>metabric %&gt;%
    mutate(across(c(Tumour_size, NPI), ~round(.x, digits = 1))) %&gt;%
    select(Patient_ID, Tumour_size, NPI)</code></pre>
<pre><code>## # A tibble: 1,904 × 3
##    Patient_ID Tumour_size   NPI
##    &lt;chr&gt;            &lt;dbl&gt; &lt;dbl&gt;
##  1 MB-0000            2.2   6.4
##  2 MB-0002            1     4.2
##  3 MB-0005            1.5   4.3
##  4 MB-0006            2.5   4.5
##  5 MB-0008            4     6.8
##  6 MB-0010            3.1   4.6
##  7 MB-0014            1     4.2
##  8 MB-0022            2.9   4.6
##  9 MB-0028            1.6   5.3
## 10 MB-0035            2.8   3.6
## # ℹ 1,894 more rows</code></pre>
<p>We can use the range operator and the same helper functions as we did
for selecting columns using <code>select()</code> inside
<code>across()</code>.</p>
<p>For example, we might decide that our expression values are given to
a much higher degree of precision than is strictly necessary.</p>
<pre class="r"><code>metabric %&gt;%
    mutate(across(ESR1:MLPH, ~round(.x, digits = 2))) %&gt;%
    select(Patient_ID, ESR1:MLPH)</code></pre>
<pre><code>## # A tibble: 1,904 × 9
##    Patient_ID  ESR1 ERBB2   PGR  TP53 PIK3CA GATA3 FOXA1  MLPH
##    &lt;chr&gt;      &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;
##  1 MB-0000     8.93  9.33  5.68  6.34   5.7   6.93  7.95  9.73
##  2 MB-0002    10.0   9.73  7.51  6.19   5.76 11.2  11.8  12.5 
##  3 MB-0005    10.0   9.73  7.38  6.4    6.75  9.29 11.7  10.3 
##  4 MB-0006    10.4  10.3   6.82  6.87   7.22  8.67 11.9  10.5 
##  5 MB-0008    11.3   9.96  7.33  6.34   5.82  9.72 11.6  12.2 
##  6 MB-0010    11.2   9.74  5.95  5.42   6.12  9.79 12.1  11.4 
##  7 MB-0014    10.8   9.28  7.72  5.99   7.48  8.37 11.5  10.8 
##  8 MB-0022    10.4   8.61  5.59  6.17   7.59  7.87 10.7   9.95
##  9 MB-0028    12.5  10.7   5.33  6.22   6.25 10.3  12.2  10.9 
## 10 MB-0035     7.54 11.5   5.59  6.41   5.99 10.2  12.8  13.5 
## # ℹ 1,894 more rows</code></pre>
<p>Or we could decide that all the columns whose names end with
“_status” are in fact categorical variables and should be converted to
factors.</p>
<pre class="r"><code>metabric %&gt;%
    mutate(across(ends_with(&quot;_status&quot;), as.factor)) %&gt;%
    select(Patient_ID, ends_with(&quot;_status&quot;))</code></pre>
<pre><code>## # A tibble: 1,904 × 7
##    Patient_ID Survival_status Vital_status Lymph_node_status ER_status PR_status
##    &lt;chr&gt;      &lt;fct&gt;           &lt;fct&gt;        &lt;fct&gt;             &lt;fct&gt;     &lt;fct&gt;    
##  1 MB-0000    LIVING          Living       3                 Positive  Negative 
##  2 MB-0002    LIVING          Living       1                 Positive  Positive 
##  3 MB-0005    DECEASED        Died of Dis… 2                 Positive  Positive 
##  4 MB-0006    LIVING          Living       2                 Positive  Positive 
##  5 MB-0008    DECEASED        Died of Dis… 3                 Positive  Positive 
##  6 MB-0010    DECEASED        Died of Dis… 1                 Positive  Positive 
##  7 MB-0014    LIVING          Living       2                 Positive  Positive 
##  8 MB-0022    DECEASED        Died of Oth… 2                 Positive  Negative 
##  9 MB-0028    DECEASED        Died of Oth… 2                 Positive  Negative 
## 10 MB-0035    DECEASED        Died of Dis… 1                 Positive  Negative 
## # ℹ 1,894 more rows
## # ℹ 1 more variable: HER2_status &lt;fct&gt;</code></pre>
<hr />
</div>
</div>
<div id="computing-summary-values-using-summarise"
class="section level1">
<h1>Computing summary values using <code>summarise()</code></h1>
<p>We’ll cover the fifth of the main dplyr ‘verb’ functions,
<strong><code>summarise()</code></strong>, only briefly here. This
function computes summary values for one or more variables (columns) in
a table. Here we will summarise values for the entire table but this
function is much more useful in combination with <code>group_by()</code>
in working on groups of observations within the data set. We will look
at summarizing groups of observations next week.</p>
<p>Any function that calculates a single scalar value from a vector can
be used with <code>summarise()</code>. For example, the
<code>mean()</code> function calculates the arithmetic mean of a numeric
vector. Let’s calculate the average ESR1 expression for tumour samples
in the METABRIC data set.</p>
<pre class="r"><code>mean(metabric$ESR1)</code></pre>
<pre><code>## [1] 9.607824</code></pre>
<p>The equivalent operation using <code>summarise()</code> is:</p>
<pre class="r"><code>summarise(metabric, mean(ESR1))</code></pre>
<pre><code>## # A tibble: 1 × 1
##   `mean(ESR1)`
##          &lt;dbl&gt;
## 1         9.61</code></pre>
<p>If you prefer Oxford spelling, in which -ize is preferred to -ise,
you’re in luck as dplyr accommodates the alternative spelling.</p>
<p>Both of the above statements gave the same average expression value
but these were output in differing formats. The <code>mean()</code>
function collapses a vector to single scalar value, which as we know is
in fact a vector of length 1. The <code>summarise()</code> function, as
with most tidyverse functions, returns another data frame, albeit one in
which there is a single row and a single column.</p>
<p>Returning a data frame might be quite useful, particularly if we’re
summarising multiple columns or using more than one function, for
example computing the average and standard deviation.</p>
<pre class="r"><code>summarise(metabric, ESR1_mean = mean(ESR1), ESR1_sd = sd(ESR1))</code></pre>
<pre><code>## # A tibble: 1 × 2
##   ESR1_mean ESR1_sd
##       &lt;dbl&gt;   &lt;dbl&gt;
## 1      9.61    2.13</code></pre>
<p>Notice how we also named the output columns in this last example.</p>
<div class="rmdblock">
<p>
<strong><code>summarise()</code></strong>
</p>
<p>
<code>summarise()</code> collapses a data frame into a single row by
calculating summary values of one or more of the columns.
</p>
<p>
It can take any function that takes a vector of values and returns a
single value. Some of the more useful functions include:
</p>
<ul>
<li>
Centre: <strong><code>mean()</code></strong>,
<strong><code>median()</code></strong>
</li>
<li>
Spread: <strong><code>sd()</code></strong>,
<strong><code>mad()</code></strong>
</li>
<li>
Range: <strong><code>min()</code></strong>,
<strong><code>max()</code></strong>,
<strong><code>quantile()</code></strong>
</li>
<li>
Position: <strong><code>first()</code></strong>,
<strong><code>last()</code></strong>
</li>
<li>
Count: <strong><code>n()</code></strong>
</li>
</ul>
<p>
Note the <code>first()</code>, <code>last()</code> and <code>n()</code>
are only really useful when working on groups of observations using
<strong><code>group_by()</code></strong>.
</p>
<p>
<strong><code>n()</code></strong> is a special function that returns the
number of observations; it doesn’t take a vector argument, i.e. a
column.
</p>
</div>
<p>It is also possible to summarise using a function that takes more
than one value, i.e. from multiple columns. For example, we could
compute the correlation between the expression of FOXA1 and MLPH.</p>
<pre class="r"><code>summarise(metabric, correlation = cor(FOXA1, MLPH))</code></pre>
<pre><code>## # A tibble: 1 × 1
##   correlation
##         &lt;dbl&gt;
## 1       0.898</code></pre>
<div id="summarizing-multiple-columns" class="section level2">
<h2>Summarizing multiple columns</h2>
<p>As with <code>mutate()</code> we can use <strong>across()</strong> to
summarise across multiple columns using the same function.</p>
<pre class="r"><code>summarise(metabric, across(c(FOXA1, MLPH), mean))</code></pre>
<pre><code>## # A tibble: 1 × 2
##   FOXA1  MLPH
##   &lt;dbl&gt; &lt;dbl&gt;
## 1  10.8  11.4</code></pre>
<p>We can use the <code>everything()</code> selector to summarise across
all the columns in the table.</p>
<pre class="r"><code>metabric %&gt;%
    select(ESR1:MLPH) %&gt;%
    summarise(across(everything(), mean))</code></pre>
<pre><code>## # A tibble: 1 × 8
##    ESR1 ERBB2   PGR  TP53 PIK3CA GATA3 FOXA1  MLPH
##   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;
## 1  9.61  10.8  6.24  6.20   5.97  9.50  10.8  11.4</code></pre>
<p>But, you have to be careful that all columns can be summarised with
the given summary function. For example, what happens if we try to
compute an average of a set of character values?</p>
<pre class="r"><code>metabric %&gt;%
    summarise(across(everything(), ~mean(.x, na.rm = TRUE)))</code></pre>
<pre><code>## Warning: There were 14 warnings in `summarise()`.
## The first warning was:
## ℹ In argument: `across(everything(), ~mean(.x, na.rm = TRUE))`.
## Caused by warning in `mean.default()`:
## ! argument is not numeric or logical: returning NA
## ℹ Run `dplyr::last_dplyr_warnings()` to see the 13 remaining warnings.</code></pre>
<pre><code>## # A tibble: 1 × 34
##   Patient_ID Cohort Age_at_diagnosis Survival_time Survival_status Vital_status
##        &lt;dbl&gt;  &lt;dbl&gt;            &lt;dbl&gt;         &lt;dbl&gt;           &lt;dbl&gt;        &lt;dbl&gt;
## 1         NA   2.64             61.1          125.              NA           NA
## # ℹ 28 more variables: Chemotherapy &lt;dbl&gt;, Radiotherapy &lt;dbl&gt;,
## #   Tumour_size &lt;dbl&gt;, Tumour_stage &lt;dbl&gt;, Neoplasm_histologic_grade &lt;dbl&gt;,
## #   Lymph_nodes_examined_positive &lt;dbl&gt;, Lymph_node_status &lt;dbl&gt;,
## #   Cancer_type &lt;dbl&gt;, ER_status &lt;dbl&gt;, PR_status &lt;dbl&gt;, HER2_status &lt;dbl&gt;,
## #   HER2_status_measured_by_SNP6 &lt;dbl&gt;, PAM50 &lt;dbl&gt;, `3-gene_classifier` &lt;dbl&gt;,
## #   Nottingham_prognostic_index &lt;dbl&gt;, Cellularity &lt;dbl&gt;,
## #   Integrative_cluster &lt;dbl&gt;, Mutation_count &lt;dbl&gt;, ESR1 &lt;dbl&gt;, ERBB2 &lt;dbl&gt;, …</code></pre>
<p>We get a lot of warning messages and <code>NA</code> values for those
columns for which computing an average does not make sense.</p>
<p>We can combine <code>across()</code> with <code>where()</code> and a
logical test (e.g. <code>is.numeric</code>) to select those columns for
which a summarization function is appropriate.</p>
<pre class="r"><code>metabric %&gt;%
    summarise(across(where(is.numeric), ~mean(.x, na.rm = TRUE)))</code></pre>
<pre><code>## # A tibble: 1 × 19
##   Cohort Age_at_diagnosis Survival_time Tumour_size Tumour_stage
##    &lt;dbl&gt;            &lt;dbl&gt;         &lt;dbl&gt;       &lt;dbl&gt;        &lt;dbl&gt;
## 1   2.64             61.1          125.        2.62         1.75
## # ℹ 14 more variables: Neoplasm_histologic_grade &lt;dbl&gt;,
## #   Lymph_nodes_examined_positive &lt;dbl&gt;, Lymph_node_status &lt;dbl&gt;,
## #   Nottingham_prognostic_index &lt;dbl&gt;, Mutation_count &lt;dbl&gt;, ESR1 &lt;dbl&gt;,
## #   ERBB2 &lt;dbl&gt;, PGR &lt;dbl&gt;, TP53 &lt;dbl&gt;, PIK3CA &lt;dbl&gt;, GATA3 &lt;dbl&gt;, FOXA1 &lt;dbl&gt;,
## #   MLPH &lt;dbl&gt;, NPI &lt;dbl&gt;</code></pre>
<p>It is possible to summarise using more than one function in which
case a list of functions needs to be provided.</p>
<pre class="r"><code>metabric %&gt;%
    summarise(across(c(ESR1, ERBB2, PGR), list(mean, sd)))</code></pre>
<pre><code>## # A tibble: 1 × 6
##   ESR1_1 ESR1_2 ERBB2_1 ERBB2_2 PGR_1 PGR_2
##    &lt;dbl&gt;  &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;
## 1   9.61   2.13    10.8    1.36  6.24  1.02</code></pre>
<p>Pretty neat but I’m not sure about those column headings in the
output – fortunately we have some control over these.</p>
<pre class="r"><code>metabric %&gt;%
    summarise(across(c(ESR1, ERBB2, PGR), list(Average = mean, stdev = sd)))</code></pre>
<pre><code>## # A tibble: 1 × 6
##   ESR1_Average ESR1_stdev ERBB2_Average ERBB2_stdev PGR_Average PGR_stdev
##          &lt;dbl&gt;      &lt;dbl&gt;         &lt;dbl&gt;       &lt;dbl&gt;       &lt;dbl&gt;     &lt;dbl&gt;
## 1         9.61       2.13          10.8        1.36        6.24      1.02</code></pre>
<p>Anonymous functions can also be used with summarise.</p>
<p>For example, suppose we want to compute the correlation of the
expression for FOXA1 against all other genes to see which was most
strongly correlated. Here is how we could do this in a single
<code>summarise()</code> statement using an anonymous function.</p>
<pre class="r"><code>metabric %&gt;%
    summarise(across(c(ESR1:MLPH, -FOXA1), ~cor(.x, FOXA1)))</code></pre>
<pre><code>## # A tibble: 1 × 7
##    ESR1 ERBB2   PGR    TP53 PIK3CA GATA3  MLPH
##   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;   &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;
## 1 0.724 0.280 0.390 -0.0700 -0.149 0.781 0.898</code></pre>
<p>Notice how we selected all genes between ESR1, the first gene column
in our data frame, and MLPH, the last gene column, but then excluded
FOXA1 as we’re not all that interested in the correlation of FOXA1 with
itself (we know the answer is 1).</p>
<hr />
</div>
</div>
<div id="faceting-with-ggplot2" class="section level1">
<h1>Faceting with ggplot2</h1>
<p>Finally, let’s change track completely and take a look at a very
useful feature of ggplot2 – <strong>faceting</strong>.</p>
<p>Faceting allows you to split your plot into subplots, or facets,
based on one or more categorical variables. Each of the subplots
displays a subset of the data.</p>
<p>There are two faceting functions,
<strong><code>facet_wrap()</code></strong> and
<strong><code>facet_grid()</code></strong>.</p>
<p>Let’s create a scatter plot of GATA3 and ESR1 expression values where
we’re displaying the PR positive and PR negative patients using
different colours. This is a very similar to a plot we created last
week.</p>
<pre class="r"><code>ggplot(data = metabric,
       mapping = aes(x = GATA3, y = ESR1, colour = PR_status)) +
    geom_point(size = 0.5, alpha = 0.5)</code></pre>
<p><img src="week5_files/figure-html/scatter_plot_2-1.png" width="672" /></p>
<p>An alternative is to use faceting with
<strong><code>facet_wrap()</code></strong>.</p>
<pre class="r"><code>ggplot(data = metabric, mapping = aes(x = GATA3, y = ESR1)) +
    geom_point(size = 0.5, alpha = 0.5) +
    facet_wrap(vars(PR_status))</code></pre>
<p><img src="week5_files/figure-html/scatter_plot_3-1.png" width="672" /></p>
<p>This produces two plots, side-by-side, one for each of the categories
in the <code>PR_status</code> variable, with a banner across the top of
each for the category.</p>
<p>The variable(s) used for faceting are specified using
<code>vars()</code> in a similar way to the selection of variables for
<code>mutate_at()</code> and <code>summarise_at()</code>.</p>
<p>We can still use separate colours if we prefer things to be, well,
colourful.</p>
<pre class="r"><code>ggplot(data = metabric,
       mapping = aes(x = GATA3, y = ESR1, colour = PR_status)) +
    geom_point(size = 0.5, alpha = 0.5) +
    facet_wrap(vars(PR_status))</code></pre>
<p><img src="week5_files/figure-html/scatter_plot_4-1.png" width="672" /></p>
<p>Faceting is usually better than displaying groups using different
colours when there are more than two or three groups when it can be
difficult to really tell which points belong to each group. A case in
point is for the 3-gene classification in the GATA3 vs ESR1 scatter plot
we created last week. Let’s create a faceted version of that plot.</p>
<pre class="r"><code>ggplot(data = metabric,
       mapping = aes(x = GATA3, y = ESR1, colour = `3-gene_classifier`)) +
    geom_point(size = 0.5, alpha = 0.5) +
    facet_wrap(vars(`3-gene_classifier`))</code></pre>
<p><img src="week5_files/figure-html/scatter_plot_5-1.png" width="672" /></p>
<p>This helps explain why the function is called
<code>facet_wrap()</code>. When it has too many subplots to fit across
the page, it wraps around to another row. We can control how many rows
or columns to use with the <code>nrow</code> and <code>ncol</code>
arguments.</p>
<pre class="r"><code>ggplot(data = metabric,
       mapping = aes(x = GATA3, y = ESR1, colour = `3-gene_classifier`)) +
    geom_point(size = 0.5, alpha = 0.5) +
    facet_wrap(vars(`3-gene_classifier`), nrow = 1)</code></pre>
<p><img src="week5_files/figure-html/scatter_plot_6-1.png" width="672" /></p>
<pre class="r"><code>ggplot(data = metabric,
       mapping = aes(x = GATA3, y = ESR1, colour = `3-gene_classifier`)) +
    geom_point(size = 0.5, alpha = 0.5) +
    facet_wrap(vars(`3-gene_classifier`), ncol = 2)</code></pre>
<p><img src="week5_files/figure-html/scatter_plot_7-1.png" width="672" /></p>
<p>We can combine faceting on one variable with a colour aesthetic for
another variable. For example, let’s show the tumour stage status using
faceting and the HER2 status using colours.</p>
<pre class="r"><code>ggplot(data = metabric,
       mapping = aes(x = GATA3, y = ESR1, colour = HER2_status)) +
    geom_point(size = 0.5, alpha = 0.5) +
    facet_wrap(vars(Neoplasm_histologic_grade))</code></pre>
<p><img src="week5_files/figure-html/scatter_plot_8-1.png" width="672" /></p>
<p>Instead of this we could facet on more than variable.</p>
<pre class="r"><code>ggplot(data = metabric, mapping = aes(x = GATA3, y = ESR1)) +
    geom_point(size = 0.5, alpha = 0.5) +
    facet_wrap(vars(Neoplasm_histologic_grade, HER2_status))</code></pre>
<p><img src="week5_files/figure-html/scatter_plot_9-1.png" width="672" /></p>
<p>Faceting on two variables is usually better done using the other
faceting function, <strong><code>facet_grid()</code></strong>. Note the
change in how the formula is written.</p>
<pre class="r"><code>ggplot(data = metabric, mapping = aes(x = GATA3, y = ESR1)) +
    geom_point(size = 0.5, alpha = 0.5) +
    facet_grid(vars(Neoplasm_histologic_grade), vars(HER2_status))</code></pre>
<p><img src="week5_files/figure-html/scatter_plot_10-1.png" width="672" /></p>
<p>Again we can use colour aesthetics alongside faceting to add further
information to our visualization.</p>
<pre class="r"><code>ggplot(data = metabric, mapping = aes(x = GATA3, y = ESR1, colour = PAM50)) +
    geom_point(size = 0.5, alpha = 0.5) +
    facet_grid(rows = vars(Neoplasm_histologic_grade),
               cols = vars(HER2_status))</code></pre>
<p><img src="week5_files/figure-html/scatter_plot_11-1.png" width="672" /></p>
<p>Finally, we can use a <code>labeller</code> to change the labels for
each of the categorical values so that these are more meaningful in the
context of this plot.</p>
<pre class="r"><code>grade_labels &lt;- c(&quot;1&quot; = &quot;Grade I&quot;, &quot;2&quot; = &quot;Grade II&quot;, &quot;3&quot; = &quot;Grade III&quot;)
her2_status_labels &lt;- c(&quot;Positive&quot; = &quot;HER2 positive&quot;,
                        &quot;Negative&quot; = &quot;HER2 negative&quot;)

ggplot(data = metabric, mapping = aes(x = GATA3, y = ESR1, colour = PAM50)) +
    geom_point(size = 0.5, alpha = 0.5) +
    facet_grid(rows = vars(Neoplasm_histologic_grade),
               cols = vars(HER2_status),
               labeller = labeller(Neoplasm_histologic_grade = grade_labels,
                                   HER2_status = her2_status_labels))</code></pre>
<p><img src="week5_files/figure-html/scatter_plot_12-1.png" width="672" /></p>
<p>This would certainly be necessary if we were to use ER and HER2
status on one side of the grid.</p>
<pre class="r"><code>er_status_labels &lt;- c(&quot;Positive&quot; = &quot;ER positive&quot;, &quot;Negative&quot; = &quot;ER negative&quot;)
#
ggplot(data = metabric, mapping = aes(x = GATA3, y = ESR1, colour = PAM50)) +
    geom_point(size = 0.5, alpha = 0.5) +
    facet_grid(rows = vars(Neoplasm_histologic_grade),
               cols = vars(ER_status, HER2_status),
               labeller = labeller(Neoplasm_histologic_grade = grade_labels,
                                   ER_status = er_status_labels,
                                   HER2_status = her2_status_labels))</code></pre>
<p><img src="week5_files/figure-html/scatter_plot_13-1.png" width="672" /></p>
<hr />
</div>
<div id="summary" class="section level1">
<h1>Summary</h1>
<p>In this session we have covered the following concepts:</p>
<ul>
<li>Building up workflows by chaining operations together using the pipe
operator</li>
<li>Sorting rows based on values in one or more columns</li>
<li>Modifying a data frame by either adding new columns or modifying
existing ones</li>
<li>Summarizing the values in one or more columns</li>
<li>Faceting of ggplot2 visualizations</li>
</ul>
<hr />
</div>
<div id="exercises" class="section level1">
<h1>Exercises</h1>
<p>These exercises will test your ability to manipulate the METABRIC
data set by changing the values of existing columns or adding new
columns by computing new variables from existing ones.</p>
<p>We are expecting you to use the 5 main dplyr ‘verb’ functions:
<code>select()</code>, <code>filter()</code>, <code>arrange()</code>,
<code>mutate()</code> and <code>summarize()</code>. Please use the pipe
operator, <code>%&gt;%</code>, in cases where more than one operation is
required to achieve the outcome requested.</p>
<pre class="r"><code>library(tidyverse)
metabric &lt;- read_csv(&quot;data/metabric_clinical_and_expression_data.csv&quot;)</code></pre>
<hr />
<p><strong>1. Investigate the subset of long-surviving breast cancer
patients that didn’t receive chemo or radiotherapy</strong></p>
<p>First obtain the subset of patients that received neither
chemotherapy or radiotherapy and survived for more than 20 years.</p>
<details>
<summary>
Answer
</summary>
<pre class="r"><code>patients &lt;- metabric %&gt;%
    mutate(Survival_time_years = Survival_time / 12) %&gt;%
    filter(Chemotherapy == &quot;NO&quot; &amp;
               Radiotherapy == &quot;NO&quot; &amp;
               Survival_time_years &gt; 20)

patients</code></pre>
<pre><code>## # A tibble: 70 × 33
##    Patient_ID Cohort Age_at_diagnosis Survival_time Survival_status Vital_status
##    &lt;chr&gt;       &lt;dbl&gt;            &lt;dbl&gt;         &lt;dbl&gt; &lt;chr&gt;           &lt;chr&gt;       
##  1 MB-0270         1             30.0          337. LIVING          Living      
##  2 MB-2517         2             60.3          268. DECEASED        Died of Oth…
##  3 MB-2610         2             59.0          281. LIVING          Living      
##  4 MB-2763         2             70.3          276. LIVING          Living      
##  5 MB-2770         2             60.3          274. LIVING          Living      
##  6 MB-2793         2             67.6          267. LIVING          Living      
##  7 MB-2797         2             50.1          253. LIVING          Living      
##  8 MB-2819         2             62.0          271. LIVING          Living      
##  9 MB-2838         2             67.1          270. LIVING          Living      
## 10 MB-2840         2             60.5          269  LIVING          Living      
## # ℹ 60 more rows
## # ℹ 27 more variables: Chemotherapy &lt;chr&gt;, Radiotherapy &lt;chr&gt;,
## #   Tumour_size &lt;dbl&gt;, Tumour_stage &lt;dbl&gt;, Neoplasm_histologic_grade &lt;dbl&gt;,
## #   Lymph_nodes_examined_positive &lt;dbl&gt;, Lymph_node_status &lt;dbl&gt;,
## #   Cancer_type &lt;chr&gt;, ER_status &lt;chr&gt;, PR_status &lt;chr&gt;, HER2_status &lt;chr&gt;,
## #   HER2_status_measured_by_SNP6 &lt;chr&gt;, PAM50 &lt;chr&gt;, `3-gene_classifier` &lt;chr&gt;,
## #   Nottingham_prognostic_index &lt;dbl&gt;, Cellularity &lt;chr&gt;, …</code></pre>
</details>
<p>Now look at the breakdown of these patients in terms of ER status.
Count the numbers of ER positive and ER negative patients in this
subset. Calculate the proportion that are ER positive.</p>
<details>
<summary>
Answer
</summary>
<pre class="r"><code>table(patients$ER_status)</code></pre>
<pre><code>## 
## Negative Positive 
##        8       62</code></pre>
<pre class="r"><code>mean(patients$ER_status == &quot;Positive&quot;)</code></pre>
<pre><code>## [1] 0.8857143</code></pre>
</details>
<p>What does this tell us? Calculate the proportion of ER positive
patients in the whole cohort by way of a comparison.</p>
<details>
<summary>
Answer
</summary>
<pre class="r"><code>table(metabric$ER_status)</code></pre>
<pre><code>## 
## Negative Positive 
##      445     1459</code></pre>
<pre class="r"><code>mean(metabric$ER_status == &quot;Positive&quot;)</code></pre>
<pre><code>## [1] 0.7662815</code></pre>
</details>
<p><strong>2. Which patients have spent the largest proportion of their
lives dealing with breast cancer? Note that the current Survival_time
column is months. Present the final results as a table showing
Patient_ID, Age, Age_at_diagnosis, Survival_time_in_years and
Proportion_of_life_since_diagnosis. Round all numbers in the final table
to 2 decimal places and sort it so that the patient with the highest
proportion is at the top.</strong></p>
<details>
<summary>
Hint
</summary>
<ol style="list-style-type: decimal">
<li>Create a column of Survival_time_years</li>
<li>Add Survival_time_years it to Age_at_diagnosis to get final Age</li>
<li>Calculate the proportion: Survival_time_years/Age</li>
</ol>
</details>
<details>
<summary>
Answer
</summary>
<pre class="r"><code>metabric %&gt;%
    mutate(Survival_time_years = Survival_time / 12) %&gt;%
    mutate(Age = Age_at_diagnosis + Survival_time_years) %&gt;%
    mutate(Proportion_of_life_since_diagnosis = Survival_time_years / Age) %&gt;%
    select(Patient_ID,
           Age,
           Age_at_diagnosis,
           Survival_time_years,
           Proportion_of_life_since_diagnosis) %&gt;%
    arrange(desc(Proportion_of_life_since_diagnosis)) %&gt;%
    mutate(across(where(is.numeric), ~round(.x, digits = 2)))</code></pre>
<pre><code>## # A tibble: 1,904 × 5
##    Patient_ID   Age Age_at_diagnosis Survival_time_years Proportion_of_life_si…¹
##    &lt;chr&gt;      &lt;dbl&gt;            &lt;dbl&gt;               &lt;dbl&gt;                   &lt;dbl&gt;
##  1 MB-0270     58.1             30.0                28.1                    0.48
##  2 MB-4332     60.0             34.4                25.7                    0.43
##  3 MB-6062     55.1             31.6                23.5                    0.43
##  4 MB-2753     53.8             31.0                22.9                    0.42
##  5 MB-2957     52.9             31.0                21.8                    0.41
##  6 MB-2823     58.5             36.0                22.5                    0.38
##  7 MB-2779     59.7             36.8                22.9                    0.38
##  8 MB-2853     58.7             36.2                22.5                    0.38
##  9 MB-4881     59.9             37.0                22.8                    0.38
## 10 MB-4375     64.3             40.0                24.3                    0.38
## # ℹ 1,894 more rows
## # ℹ abbreviated name: ¹​Proportion_of_life_since_diagnosis</code></pre>
</details>
</div>



</div>
</div>

</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.odd').parent('tbody').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- tabsets -->

<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});

$(document).ready(function () {
  $('.tabset-dropdown > .nav-tabs > li').click(function () {
    $(this).parent().toggleClass('nav-tabs-open');
  });
});
</script>

<!-- code folding -->

<script>
$(document).ready(function ()  {

    // temporarily add toc-ignore selector to headers for the consistency with Pandoc
    $('.unlisted.unnumbered').addClass('toc-ignore')

    // move toc-ignore selectors from section div to header
    $('div.section.toc-ignore')
        .removeClass('toc-ignore')
        .children('h1,h2,h3,h4,h5').addClass('toc-ignore');

    // establish options
    var options = {
      selectors: "h1,h2,h3",
      theme: "bootstrap3",
      context: '.toc-content',
      hashGenerator: function (text) {
        return text.replace(/[.\\/?&!#<>]/g, '').replace(/\s/g, '_');
      },
      ignoreSelector: ".toc-ignore",
      scrollTo: 0
    };
    options.showAndHide = true;
    options.smoothScroll = true;

    // tocify
    var toc = $("#TOC").tocify(options).data("toc-tocify");
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
